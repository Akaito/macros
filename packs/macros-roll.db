{"_id":"9TsgblYH0WTlDE9S","name":"Stealth Check","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"chat","flags":{},"scope":"global","command":"// getting all actors of selected tokens\nlet actors = canvas.tokens.controlledTokens.map(({ actor }) => actor);\n\n// if there are no selected tokens, roll for the player's character.\nif (actors.length < 1) {\n  actors = game.users.entities.map(entity => {\n    if (entity.active && entity.character !== null) {\n      return entity.character;\n    }\n  });\n}\nconst validActors = actors.filter(actor => actor != null);\n\nlet messageContent = 'pp = passive perception<br>';\n\n// roll for every actor\nfor (const selectedActor of validActors) {\n  const stealthMod = selectedActor.data.data.skills.ste.mod; \n  const stealth = new Roll(`1d20+${stealthMod}`).roll().total; \n  messageContent += `<hr><h3>${selectedActor.name} stealth roll was a <b>${stealth}</b>.</h3>`;\n\n  // grab a list of unique tokens then check their passive perception against the rolled stealth.\n  const uniqueActor = {};\n  const caughtBy = canvas.tokens.placeables\n    .filter((token) => { // filter out duplicate token names. ie: we assume all goblins have the same passive perception\n      if (!token.actor || uniqueActor[token.actor.name]) {\n        return false;\n      }\n      uniqueActor[token.actor.name] = true;\n      return true;\n    })\n    .filter(token => {\n      return selectedActor.id !== token.actor.id; // Don't check to see if the token sees himself.\n    })\n    .filter(({ actor }) => actor.data.data.skills.prc.passive >= stealth); // check map tokens passives with roller stealth\n\n  if (!caughtBy.length) {\n    messageContent += 'Stealth successful!<br>';\n  } else {\n    messageContent += 'Stealth questionable:<br>';\n    caughtBy.map(({ actor }) => {\n      messageContent += `<b>${actor.name}</b> pp(${actor.data.data.skills.prc.passive}).<br>`;\n    });\n  }\n}\n\n// create the message\nconst chatData = {\n  user: game.user._id,\n  speaker: game.user,\n  content: messageContent,\n  whisper: game.users.entities.filter((u) => u.isGM).map((u) => u._id),\n};\nChatMessage.create(chatData, {});\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"DKxkQhiyOQMCCcGG","name":"Wandering Monsters","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"chat","flags":{},"scope":"global","command":"// setting variables\nlet msgContent = 'Wandering Monster roll was: ';\nlet result = '';\n\n// roll to check for wandering monster\nresult = new Roll(`1d20`).roll().total;\n\n// create the message\nif(result !== '') {\n  let chatData = {\n    content: msgContent + result,\n    whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n  };\n  ChatMessage.create(chatData, {});\n}\n\n// This requires you to have an existing Table built in Foundry VTT. Replace the table name below with your table name.\n// In this example, a roll between 17-20 will generate a roll from the Table. Tweak as needed!\nif (result >= 17) {\n  const table = game.tables.entities.find(t => t.name === \n  \"Wandering Monsters\");\n  table.draw();\n}","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"GgFydAwlZwXQocph","name":"Roll Table","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"chat","flags":{},"scope":"global","command":"// Simple macro example to only roll from a table and whisper the result to the DM\n\nconst table = game.tables.entities.find(t => t.name === \"name of your table\");\nlet roll = table.roll();\n\nlet chatData = {\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker(),\n    content: roll[1].text,\n    whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n};\nChatMessage.create(chatData, {});","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"ZaiiiR9KPBfzHvea","name":"Roll Initiatives","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"chat","flags":{},"scope":"global","command":"/**\n * Takes all selected tokens and adds them to the combat tracker. Then rolls initative for all NPC tokens.\n */\n\nasync function start() {\n  for ( let token of canvas.tokens.controlled) {      \n    if (token.inCombat === false){\n      // Change 'rollNPC' to 'rollAll' if you want to roll for your players as well.\n      await token.toggleCombat().then(() => game.combat.rollNPC(null, {rollMode: 'gmroll'}));\n    }\n  }\n}\n\nstart();","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"ZaiiiR9KPBfzHvea","name":"Roll Initiatives","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Takes all selected tokens and adds them to the combat tracker. Then rolls initative for all NPC tokens.\n */\n\nasync function start() {\n  for ( let token of canvas.tokens.controlled) {      \n    if (token.inCombat === false){\n      // Change 'rollNPC' to 'rollAll' if you want to roll for your players as well.\n      await token.toggleCombat().then(() => game.combat.rollNPC(null, {rollMode: 'gmroll'}));\n    }\n  }\n}\n\nstart();","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"GgFydAwlZwXQocph","name":"Roll Table","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Simple macro example to only roll from a table and whisper the result to the DM\n\nconst table = game.tables.entities.find(t => t.name === \"name of your table\");\nlet roll = table.roll();\n\nlet chatData = {\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker(),\n    content: roll[1].text,\n    whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n};\nChatMessage.create(chatData, {});","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"9TsgblYH0WTlDE9S","name":"Stealth Check","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// getting all actors of selected tokens\nlet actors = canvas.tokens.controlledTokens.map(({ actor }) => actor);\n\n// if there are no selected tokens, roll for the player's character.\nif (actors.length < 1) {\n  actors = game.users.entities.map(entity => {\n    if (entity.active && entity.character !== null) {\n      return entity.character;\n    }\n  });\n}\nconst validActors = actors.filter(actor => actor != null);\n\nlet messageContent = 'pp = passive perception<br>';\n\n// roll for every actor\nfor (const selectedActor of validActors) {\n  const stealthMod = selectedActor.data.data.skills.ste.mod; \n  const stealth = new Roll(`1d20+${stealthMod}`).roll().total; \n  messageContent += `<hr><h3>${selectedActor.name} stealth roll was a <b>${stealth}</b>.</h3>`;\n\n  // grab a list of unique tokens then check their passive perception against the rolled stealth.\n  const uniqueActor = {};\n  const caughtBy = canvas.tokens.placeables\n    .filter((token) => { // filter out duplicate token names. ie: we assume all goblins have the same passive perception\n      if (!token.actor || uniqueActor[token.actor.name]) {\n        return false;\n      }\n      uniqueActor[token.actor.name] = true;\n      return true;\n    })\n    .filter(token => {\n      return selectedActor.id !== token.actor.id; // Don't check to see if the token sees himself.\n    })\n    .filter(({ actor }) => actor.data.data.skills.prc.passive >= stealth); // check map tokens passives with roller stealth\n\n  if (!caughtBy.length) {\n    messageContent += 'Stealth successful!<br>';\n  } else {\n    messageContent += 'Stealth questionable:<br>';\n    caughtBy.map(({ actor }) => {\n      messageContent += `<b>${actor.name}</b> pp(${actor.data.data.skills.prc.passive}).<br>`;\n    });\n  }\n}\n\n// create the message\nconst chatData = {\n  user: game.user._id,\n  speaker: game.user,\n  content: messageContent,\n  whisper: game.users.entities.filter((u) => u.isGM).map((u) => u._id),\n};\nChatMessage.create(chatData, {});\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"DKxkQhiyOQMCCcGG","name":"Wandering Monsters","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// setting variables\nlet msgContent = 'Wandering Monster roll was: ';\nlet result = '';\n\n// roll to check for wandering monster\nresult = new Roll(`1d20`).roll().total;\n\n// create the message\nif(result !== '') {\n  let chatData = {\n    content: msgContent + result,\n    whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n  };\n  ChatMessage.create(chatData, {});\n}\n\n// This requires you to have an existing Table built in Foundry VTT. Replace the table name below with your table name.\n// In this example, a roll between 17-20 will generate a roll from the Table. Tweak as needed!\nif (result >= 17) {\n  const table = game.tables.entities.find(t => t.name === \n  \"Wandering Monsters\");\n  table.draw();\n}","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"9TsgblYH0WTlDE9S","name":"Stealth Check","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// getting all actors of selected tokens\nlet actors = canvas.tokens.controlledTokens.map(({ actor }) => actor);\n\n// if there are no selected tokens, roll for the player's character.\nif (actors.length < 1) {\n  actors = game.users.entities.map(entity => {\n    if (entity.active && entity.character !== null) {\n      return entity.character;\n    }\n  });\n}\nconst validActors = actors.filter(actor => actor != null);\n\nlet messageContent = 'pp = passive perception<br>';\n\n// roll for every actor\nfor (const selectedActor of validActors) {\n  const stealthMod = selectedActor.data.data.skills.ste.mod; // stealth roll\n  const stealth = new Roll(`1d20+${stealthMod}`).roll().total; // rolling the formula\n  messageContent += `<hr><h3>${selectedActor.name} stealth roll was a <b>${stealth}</b>.</h3>`; // creating the output string\n\n  // grab a list of unique tokens then check their passive perception against the rolled stealth.\n  const uniqueActor = {};\n  const caughtBy = canvas.tokens.placeables\n    .filter(token => !!token.actor)\n    .filter(({ actor }) => { // filter out duplicate token names. ie: we assume all goblins have the same passive perception\n      if (uniqueActor[actor.name]) {\n        return false;\n      }\n      uniqueActor[actor.name] = true;\n      return true;\n    })\n    .filter(({ actor }) => {\n      return selectedActor.id !== actor.id; // Don't check to see if the token sees himself.\n    })\n    .filter(({ actor }) => actor.data.data.skills.prc.passive >= stealth); // check map tokens passives with roller stealth\n\n  if (!caughtBy.length) {\n    messageContent += 'Stealth successful!<br>';\n  } else {\n    messageContent += 'Stealth questionable:<br>';\n    caughtBy.map(({ actor }) => {\n      messageContent += `<b>${actor.name}</b> pp(${actor.data.data.skills.prc.passive}).<br>`;\n    });\n  }\n}\n\n// create the message\nconst chatData = {\n  user: game.user._id,\n  speaker: game.user,\n  content: messageContent,\n  whisper: game.users.entities.filter((u) => u.isGM).map((u) => u._id),\n};\nChatMessage.create(chatData, {});\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Monk Ki","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Monk Ki Point spender\n * \n * This macro will prompt which Feature you want to spend Ki points on.\n * \n * Flurry of Blows: Automatically cast two Unarmed Strike's\n * Stunning Strike: Automatically show the saving throw DC\n * Deflect Missiles: Automatically show the damage reduction\n */\n(async () => {\n    const kiName = \"Ki Points\";\n    const errNoMonkToken = \"Please select a single monk token.\";\n\n    const sendChat = async (msg) => {\n        let chatData = {\n            user: game.user.id,\n            speaker: ChatMessage.getSpeaker(),\n            content: msg,\n        };\n        ChatMessage.create(chatData, {});\n    }\n\n    if (!actor) {\n        ui.notifications.warn(errNoMonkToken);\n        return\n    }\n\n    let monk = actor.items.find(i => i.name === 'Monk' && i.type === 'class');\n    if (!monk) {\n        ui.notifications.warn(errNoMonkToken);\n        return\n    }\n\n    let monkLevels = monk.data.data.levels || 20;\n    //let subClass = monk.data.data.subclass;\n\n    if (monkLevels < 2) {\n        ui.notifications.warn('You must have a least 2 Monk levels to use ki points.');\n        return\n    }\n\n    class KiFeature {\n        /**\n         * @param {string} name\n         * @param {string} fallbackText\n         * @param {number} requireLevel\n         * @param {function} action\n         * @param {function} appendTemplate\n         * @param {number} kiCost\n         */\n        constructor(name, fallbackText, requireLevel, action, appendTemplate, kiCost) {\n            this.name = name;\n            this.fallbackText = fallbackText;\n            this.requireLevel = requireLevel;\n            this.kiCost = kiCost || 1;\n            if (action) {\n                this.action = action;\n            }\n            if (appendTemplate) {\n                this.appendTemplate = appendTemplate;\n            }\n        }\n\n        render(allowHigher) {\n            let entry = null;\n\n            const pack = game.packs.get(\"dnd5e.classfeatures\");\n            if (!pack) {\n                console.warn('Could not find \"dnd5e.classfeatures\" compendium.');\n            } else {\n                entry = pack.index.find(e => e.name === this.name);\n            }\n\n            if (!allowHigher && this.requireLevel && monkLevels && this.requireLevel > monkLevels) {\n                ui.notifications.warn(`You need to have ${this.requireLevel} monk levels, you only have ${monkLevels}.`)\n                return\n            }\n\n            if (entry) {\n                pack.getEntity(entry._id).then(o => {\n                    let template = `@Compendium[dnd5e.classfeatures.${entry._id}]{${this.name}}\n                    ${o.data.data.description.value}`;\n                    if (this.appendTemplate) {\n                        template += '\\n\\n' + this.appendTemplate();\n                    }\n                    sendChat(template);\n                    if (this.action) {\n                        this.action();\n                    }\n                });\n            } else {\n                console.warn(`Could not find \"${this.name}\" entry in compendium.`);\n                let template = this.fallbackText;\n                if (this.appendTemplate) {\n                    template += '\\n\\n' + this.appendTemplate();\n                }\n                sendChat(template);\n                if (this.action) {\n                    this.action();\n                }\n            }\n        }\n    }\n\n   const openHand = !!actor.items.find(o => o.data.name === 'Open Hand Technique') ? `<br />In addition, you can impose one of the following: <ul><li>It must succeed on a <b>Dexterity</b> saving throw or be knocked prone.</li><li>It must make a <b>Strength</b> saving throw. If it fails, you can push it up to 15 feet away from you.</li><li>It can’t take reactions until the end of your next turn.</li></ul> Saving throw <b>DC ${10 + actor.data.data.abilities.wis.mod}</b>` : \"\";\n\n    const features = [\n        new KiFeature(\"Ki: Flurry of Blows\",\n            `Immediately after you take the <b>Attack</b> action on your turn, you can spend 1 ki point to make two unarmed strikes as a bonus action. ${openHand}`,\n            2,\n            function () {\n                // Automatically roll two Unarmed Strike attacks\n                let strike = actor.items.find(o => o.data.name === 'Unarmed Strike' && o.data.labels.activation === '1 Action')\n                if (strike) {\n                    strike.roll();\n                    strike.roll();\n                }\n            }),\n        new KiFeature(\"Ki: Patient Defense\",\n            \"You can spend 1 ki point to take the <b>Dodge</b> action as a bonus action on your turn.\",\n            2),\n        new KiFeature(\"Ki: Step of the Wind\",\n            \"You can spend 1 ki point to take the <b>Disengage</b> or <b>Dash</b> action as a bonus action on your turn, and your jump distance is doubled for the turn.\",\n            2),\n        new KiFeature(\"Deflect Missiles\",\n            `Starting at 3rd level, you can use your reaction to deflect or catch the missile when you are hit by a ranged weapon attack. When you do so, the damage you take from the attack is reduced by 1d10 + your Dexterity modifier + your monk level. <br />\n\n        If you reduce the damage to 0, you can catch the missile if it is small enough for you to hold in one hand and you have at least one hand free. If you catch a missile in this way, you can spend 1 ki point to make a ranged attack with the weapon or piece of ammunition you just caught, as part of the same reaction. You make this attack with proficiency, regardless of your weapon proficiencies, and the missile counts as a monk weapon for the attack, which has a normal range of 20 feet and a long range of 60 feet.`,\n            3,\n            null,\n            function () {\n                return `Damage reduction: [[/r 1d10+${actor.data.data.abilities.dex.mod}+${monkLevels}]]`;\n            }),\n        new KiFeature(\"Ki: Stunning Strike\",\n            \"Starting at 5th level, you can interfere with the flow of ki in an opponent’s body. When you hit another creature with a melee weapon attack, you can spend 1 ki point to attempt a stunning strike. The target must succeed on a Constitution saving throw or be <b>stunned</b> until the end of your next turn.\",\n            5,\n            null,\n            function () {\n                // Append the saving throw DC to the chat message\n                return `CON saving throw (DC [[8+${actor.data.data.abilities.wis.mod}+@attributes.prof]])`;\n            }),\n        new KiFeature(\"Ki: Diamond Soul\",\n            `Beginning at 14th level, your mastery of ki grants you proficiency in all saving throws.\n\n        Additionally, whenever you make a saving throw and fail, you can spend 1 ki point to reroll it and take the second result.`,\n            14),\n        new KiFeature(\"Ki: Empty Body\",\n            `Beginning at 18th level, you can use your action to spend 4 ki points to become invisible for 1 minute. During that time, you also have resistance to all damage but force damage.\n\n        Additionally, you can spend 8 ki points to cast the astral projection spell, without needing material components. When you do so, you can’t take any other creatures with you.`,\n            18,\n            null,\n            function () {\n                return \"Note: 4 ki points have been spent. Adjust manually if casting astral projection spell.\";\n            },\n            4),\n    ];\n\n    const consumeKi = (feature, allowNegative, allowHigher) => {\n        let hasAvailableResource = false;\n        let selected = features.find(o => o.name == feature);\n        let kiCost = selected.kiCost || 1;\n\n        // Look for Resources under the Core actor data\n        let resourceKey = Object.keys(actor.data.data.resources).filter(k => actor.data.data.resources[k].label === kiName).shift();\n        if (resourceKey && (actor.data.data.resources[resourceKey].value >= kiCost || allowNegative)) {\n            hasAvailableResource = true;\n            actor.data.data.resources[resourceKey].value -= kiCost;\n        }\n\n        // Look for Ki Points Feat that has uses\n        actor.items.filter(i => i.data.name === kiName && i.data.hasUses && (i.data.data.uses.value >= kiCost || allowNegative)).forEach(i => {\n            hasAvailableResource = true;\n            i.data.data.uses.value -= kiCost\n        })\n\n        if (!hasAvailableResource) {\n            ui.notifications.warn(`${actor.name} does not have any ${kiName} left!`);\n            return false;\n        }\n        if (actor.sheet.rendered) {\n            // Update the actor sheet if it is currently open\n            actor.render(true);\n        }\n\n        if (selected) {\n            selected.render(allowHigher);\n        }\n\n        return true;\n    };\n\n    (async () => {\n        let template = `\n        <form>\n            <div class=\"form-group\">\n                <label>Select feature:</label>\n                <select id=\"feature\" name=\"feature\">`\n        features.filter(o => o.requireLevel <= monkLevels).forEach(o => {\n            template += `<option value=\"${o.name}\">${o.name}</option>`;\n        });\n        template += `</select>\n            </div>\n            <div class=\"form-group\">\n                <label>Allow consuming Ki into negative? <input type=\"checkbox\" id=\"allow-negative\" name=\"allow-negative\" value=\"1\"></label>\n            </div>\n            <div class=\"form-group\">\n                <label>Allow consuming Ki feats of higher level? <input type=\"checkbox\" id=\"allow-higher\" name=\"allow-higher\" value=\"1\"></label>\n            </div>\n        </form>`;\n        new Dialog({\n            title: `Monk Ki Point Spender`,\n            content: template,\n            buttons: {\n                yes: {\n                    icon: \"<i class='fas fa-check'></i>\",\n                    label: `Apply`,\n                    callback: (html) => {\n                        let feature = html.find('#feature')[0].value;\n                        let allowNegative = html.find('#allow-negative')[0].checked;\n                        let allowHigher = html.find('#allow-higher')[0].checked;\n                        consumeKi(feature, allowNegative, allowHigher);\n                    }\n                },\n                no: {\n                    icon: \"<i class='fas fa-times'></i>\",\n                    label: `Cancel`\n                },\n            },\n            default: \"yes\"\n        }).render(true);\n    })();\n})()\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"Z9rqky3bjBd4qWcC"}
