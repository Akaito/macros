{"name":"Roll Knowledge Skill Check","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"const tokens = canvas.tokens.controlled;\nconst caster = tokens[0];\n\nif (tokens.length !== 1) {\n  ui.notifications.warn(\"Please select a token\");\n} else {\n  const knowledgeTypes = [\n    \"Arcana\",\n    \"Dungeoneering\",\n    \"Engineering\",\n    \"Geography\",\n    \"History\",\n    \"Local\",\n    \"Nature\",\n    \"Nobility\",\n    \"Planes\",\n    \"Religion\",\n  ];\n\n  const knowledgeData = [];\n  knowledgeTypes.forEach((type) => {\n    const knowledgeDatum =\n      caster.actor.data.data.skills[`k${type.toLowerCase().substring(0, 2)}`];\n    knowledgeDatum.name = type;\n    knowledgeData.push(knowledgeDatum);\n  });\n\n  const knownKnowledge = knowledgeData.filter((datum) => datum.rank > 0);\n\n  if (knownKnowledge.length < 1) {\n    ui.notifications.warn(\"You know nothing.\");\n  } else {\n    const buttons = {};\n    knownKnowledge.forEach((type) => {\n      buttons[type.name] = {\n        label: type.name,\n        callback: () => {\n          rollCheck(type.name, type.mod);\n        },\n      };\n    });\n\n    new Dialog({\n      title: \"Roll Knowledge!\",\n      content: `<p>Choose a knowledge skill</p>`,\n      buttons: buttons,\n    }).render(true);\n  }\n}\n\nfunction rollCheck(name, mod) {\n  const roll = new Roll(`1d20 + ${mod}`);\n  roll.roll();\n  roll.toMessage({\n    flavor: `Knowledge ${name} check`,\n    speaker: { alias: token.actor.data.name },\n  });\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"04I4j1YSxYklODQH"}
{"_id":"9TsgblYH0WTlDE9S","name":"Stealth Check","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Grabs selected tokens and rolls a stealth check against all other tokens passive perception on the map. Then returns the result.\n\n// getting all actors of selected tokens\nlet actors = canvas.tokens.controlled.map(({ actor }) => actor);\n\n// if there are no selected tokens, roll for the player's character.\nif (actors.length < 1) {\n  actors = game.users.entities.map(entity => {\n    if (entity.active && entity.character !== null) {\n      return entity.character;\n    }\n  });\n}\nconst validActors = actors.filter(actor => actor != null);\n\nlet messageContent = 'pp = passive perception<br>';\n\n// roll for every actor\nfor (const selectedActor of validActors) {\n  const stealthMod = selectedActor.data.data.skills.ste.total; // stealth roll\n  const stealth = new Roll(`1d20+${stealthMod}`).roll().total; // rolling the formula\n  messageContent += `<hr><h3>${selectedActor.name} stealth roll was a <b>${stealth}</b>.</h3>`; // creating the output string\n\n  // grab a list of unique tokens then check their passive perception against the rolled stealth.\n  const uniqueActor = {};\n  const caughtBy = canvas.tokens.placeables\n    .filter(token => !!token.actor)\n    .filter(({ actor }) => { // filter out duplicate token names. ie: we assume all goblins have the same passive perception\n      if (uniqueActor[actor.name]) {\n        return false;\n      }\n      uniqueActor[actor.name] = true;\n      return true;\n    })\n    .filter(({ actor }) => {\n      return selectedActor.id !== actor.id; // Don't check to see if the token sees himself.\n    })\n    .filter(({ actor }) => actor.data.data.skills.prc.passive >= stealth); // check map tokens passives with roller stealth\n\n  if (!caughtBy.length) {\n    messageContent += 'Stealth successful!<br>';\n  } else {\n    messageContent += 'Stealth questionable:<br>';\n    caughtBy.map(({ actor }) => {\n      messageContent += `<b>${actor.name}</b> pp(${actor.data.data.skills.prc.passive}).<br>`;\n    });\n  }\n}\n\n// create the message\nconst chatData = {\n  user: game.user._id,\n  speaker: game.user,\n  content: messageContent,\n  whisper: game.users.entities.filter((u) => u.isGM).map((u) => u._id),\n};\nChatMessage.create(chatData, {});\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Roll Channel Positive Healing","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// CONFIGURATION\n// Leave casterName as null to channel positive as the currently-selected character\n// Example `const casterName = \"Bob Bobbington\";`\nconst casterName = null;\n\nconst tokens = canvas.tokens.controlled;\nlet caster = tokens.map((o) => o.actor)[0];\nif (!caster && !!casterName) {\n    caster = game.actors.entities.filter((o) => o.name.includes(casterName))[0];\n}\n\nfunction channelPositive() {\n  if (!caster.data.data.classes.cleric) {\n    ui.notifications.warn(\"You're not a cleric!\");\n    return;\n  }\n  const clericLevel = caster.data.data.classes.cleric.level;\n  const rollString = `${Math.floor((clericLevel + 1) / 2)}d6`;\n\n  const roll = new Roll(rollString);\n  roll.roll();\n  roll.toMessage({\n    flavor: \"Channeling positive energy\",\n  });\n}\n\nif (!caster || caster === undefined) {\n  ui.notifications.warn(\"You need to be controlling someone to channel!\")\n} else {\n  channelPositive();\n}","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"AZqotCw6PiH5jB2R"}
{"_id":"DKxkQhiyOQMCCcGG","name":"Wandering Monsters","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// setting variables\nlet tableName = \"Wandering Monsters\";\nlet msgContent = 'Wandering Monster roll was: ';\nlet result = '';\n\n// roll to check for wandering monster\nresult = new Roll(`1d20`).roll().total;\n\n// create the message\nif(result !== '') {\n  let chatData = {\n    content: msgContent + result,\n    whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n  };\n  ChatMessage.create(chatData, {});\n}\n\n// In this example, a roll between 17-20 will generate a roll from the Table. Tweak as needed!\nif (result >= 17) {\n  const table = game.tables.entities.find(t => t.name === tableName);\n  table.draw();\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"GgFydAwlZwXQocph","name":"Roll Table","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Simple macro example to only roll from a table and whisper the result to the DM\n\nconst table = game.tables.entities.find(t => t.name === \"name of your table\");\nlet roll = table.roll();\n\nlet chatData = {\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker(),\n    content: roll.results[0].text,\n    whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n};\nChatMessage.create(chatData, {});\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"ZaiiiR9KPBfzHvea","name":"Roll Initiatives","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Takes all selected tokens and adds them to the combat tracker. Then rolls initative for all NPC tokens.\n */\n\nasync function start() {\n  for ( let token of canvas.tokens.controlled) {      \n    if (token.inCombat === false){\n      // Change 'rollNPC' to 'rollAll' if you want to roll for your players as well.\n      await token.toggleCombat().then(() => game.combat.rollNPC(null, {rollMode: 'gmroll'}));\n    }\n  }\n}\n\nstart();\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Hit Target Healing","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// this script attempts to heal X points of damage by repeatedly using charges of wands of cure light wounds\n\nfunction hitTarget(target) {\n  if (target > 250) {\n    ui.notifications.warn(\n      \"Too much healing! No one needs that much healing! Max 250.\"\n    );\n    return;\n  }\n  let current = 0;\n  let chargesUsed;\n\n  const rolls = [];\n  for (chargesUsed = 0; current < target; chargesUsed += 1) {\n    const roll = new Roll(\"1d8 + 1\");\n    roll.roll();\n    current += roll.total;\n    rolls.push({ roll: roll.total - 1 });\n  }\n\n  const roll = new Roll(`${chargesUsed}d8 + ${chargesUsed}`);\n  const msg = roll.toMessage(\n    { flavor: `Casting <i>cure light wounds</i> ${chargesUsed} times` },\n    { create: false }\n  );\n\n  const fakeRoll = {\n    class: \"Roll\",\n    formula: `${chargesUsed}d8 + ${chargesUsed}`,\n    dice: [\n      {\n        class: \"Die\",\n        faces: 8,\n        rolls: rolls,\n        formula: `${chargesUsed}d8`,\n        options: {},\n      },\n    ],\n    parts: [\"_d0\", \"+\", `${chargesUsed}`],\n    result: `${current - chargesUsed} + ${chargesUsed}`,\n    total: current,\n  };\n\n  msg.roll = JSON.stringify(fakeRoll);\n  msg.content = String(current);\n\n  const tokens = canvas.tokens.controlled;\n  if (tokens.length !== 1) {\n    ui.notifications.warn(\"Please select a token.\");\n    return;\n  }\n  const token = tokens[0];\n  msg.speaker = {alias: token.actor.data.name}\n\n  ChatMessage.create(msg);\n}\n\nnew Dialog({\n  title: \"Cast until heal a set amount\",\n  content:\n    \"<p>Enter the amount you want to heal</p><center><input type='number' id='amountInput'></center><br>\",\n  buttons: {\n    submit: {\n      label: \"Heal\",\n      icon: '<i class=\"fas fa-medkit\"></i>',\n      callback: () => {\n        const healTarget = parseInt(\n          eval(\n            $(\"#amountInput\")\n              .val()\n              .match(/[0-9]*/g)\n          )\n        );\n        hitTarget(healTarget);\n      },\n    },\n  },\n}).render(true);\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"mt0Ls0ddpvslE0BT"}
{"name":"Mass Roll Check","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/*\n* Gets a list of selected tokens (or defaults to the user's character), provides a list of\n* skills, and then makes a roll for all the selected tokens with that skill. It then spits out\n* the poorly-formatted results to chat (or the GM if you uncomment the whisper line).\n*/\n\nlet targetActors = getTargetActors().filter(a => a != null);\nif (!targetActors.length > 0)\n    return;\n\n// Choose roll type dialog\nlet rollTypeTemplate = `\n<div>\n    <div class=\"form-group\">\n        <label>Choose roll type</label>\n        <select id=\"selectedType\">\n            <option value=\"save\">Saving Throw</option>\n            <option value=\"ability\">Ability Check</option>\n            <option value=\"skill\">Skill Check</option>\n        </select>\n    </div>\n</div>`;\n\nlet chooseCheckType = new Dialog({\n    title: \"Choose check type\",\n    content: rollTypeTemplate,\n    buttons: {\n        ok: {\n            icon: '<i class=\"fas fa-check\"></i>',\n            label: \"OK\",\n            callback:  async (html) => {\n                let checkType = html.find(\"#selectedType\")[0].value;\n                selectedCheckDialog(checkType).render(true);\n            }\n        },\n        cancel: {\n            icon: '<i class=\"fas fa-times\"></i>',\n            label: 'Cancel'\n        }\n    },\n    default: \"cancel\"\n});\n\n// Choose ability mod dialog\nfunction selectedCheckDialog(checkType) {\n\n    let dialogTitle = getCheckDialogTitle(checkType);\n    let dialogContent = getCheckTemplate(checkType);\n\n    return new Dialog({\n        title: dialogTitle,\n        content: dialogContent,\n        buttons: {\n            ok: {\n                icon: '<i class=\"fas fa-check\"></i>',\n                label: \"OK\",\n                callback: async (html) => {\n                    let id = html.find(\"#selectedAbility\")[0].value;\n\n                    let messageContent = `<div><h2>${checkType.toUpperCase()} Roll</h2></div>`\n                    for (let a of targetActors) {\n                        let name = a.name;\n                        let mod = 0;               \n                        switch (checkType) {\n                            case \"save\":\n                                mod = a.data.data.abilities[id].save;\n                                messageContent += `${name}: <b>[[1d20+${mod}]]</b> (${game.dnd5e.config.abilities[id]} saving throw)<br>`;\n                                break;\n                            case \"ability\":\n                                mod = a.data.data.abilities[id].mod + a.data.data.abilities[id].checkBonus;\n                                messageContent += `${name}: <b>[[1d20+${mod}]]</b> (${game.dnd5e.config.abilities[id]} check)<br>`;\n                                break;\n                            case \"skill\":\n                                mod = a.data.data.skills[id].total;\n                                messageContent += `${name}: <b>[[1d20+${mod}]]</b> (${game.dnd5e.config.skills[id]} (${a.data.data.skills[id].ability}) check)<br>`;\n                                break;\n                            default:\n                                objects = game.dnd5e.config.skills;\n                                break;\n                        }\n                    }\n    \n                    let chatData = {\n                        user: game.user.id,\n                        speaker: game.user,\n                        content: messageContent,\n                        // Uncomment the following line if you want the results whispered to the GM.\n                        // whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n                    };\n                    ChatMessage.create(chatData, {});\n                }\n            },\n            cancel: {\n                icon: '<i class=\"fas fa-times\"></i>',\n                label: 'Cancel'\n            }\n        },\n        default: \"cancel\"\n    });\n}\n\n// Gets list of selected tokens, or if no tokens are selected then the user's character.\nfunction getTargetActors() {\n    const character = game.user.character;\n    const controlled = canvas.tokens.controlled;\n    let actors = [];\n\n    if (controlled.length === 0) return [character] || null;\n\n    if (controlled.length > 0) {\n        let actors = [];\n        for (let i = 0; i < controlled.length; i++) {\n            actors.push(controlled[i].actor);\n    }\n\n    return actors;\n}\nelse throw new Error('You must designate at least one token as the roll target');\n}\n\n\n// Gets a template of abilities or skills, based on the type of check chosen.\nfunction getCheckTemplate(checkType) {\n    let objects = new Object();\n    \n    switch (checkType) {\n        case \"save\":\n        case \"ability\":\n            objects = game.dnd5e.config.abilities;\n            break;\n        case \"skill\":\n            objects = game.dnd5e.config.skills;\n            break;\n        default:\n            objects = game.dnd5e.config.skills;\n            break;\n    }\n\n    let template = `\n    <div>\n        <div class=\"form-group\">\n            <label>Choose check</label>\n            <select id=\"selectedAbility\">`\n    \n            for (let [checkId, check] of Object.entries(objects)) {\n                template += `<option value=\"${checkId}\">${check}</option>`;    \n            }            \n    \n    template += `</select>\n        </div>\n    </div>`;\n\n    return template;\n}\n\nfunction getCheckDialogTitle(checkType) {\n    switch (checkType) {\n        case \"save\":\n            return \"Saving Throw\"\n        case \"ability\":\n            return \"Ability Check\"\n        case \"skill\":\n            return \"Skill Check\"\n        default:\n            return \"Unknown Check\"\n    }\n}\n\nchooseCheckType.render(true);","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"sXxLpBqCRhCQeGLV"}
{"name":"Token HP","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Roll/Reroll selected token HP\n * Author: Tielc#7191\n */\n\nconst tokens = canvas.tokens.controlled;\nlet choice = 0;\n\nif (tokens.length > 0){\n\ttokens.forEach(rollHP);\n} else {\n\tprintMessage(\"No Tokens were selected\");\n}\n\nfunction rollHP(token, index){\n\tlet actor = token.actor;\n\tlet formula = actor.data.data.attributes.hp.formula;\n\t\t\n\tif (actor.data.type != \"npc\" || !formula) return;\n\t\n\tlet hp = new Roll(formula).roll().total;\n\t\n\tactor.data.data.attributes.hp.value = hp;\n\tactor.data.data.attributes.hp.max = hp;\n\t\n\tprintMessage('<h2>' + actor.data.name + '</h2><strong>HP:</strong> ' + actor.data.data.attributes.hp.value + '/' + actor.data.data.attributes.hp.max + '<span style=\"float:right\"><em>(' + token.data._id + ')</em></span>');\n}\n\nfunction printMessage(message){\n\tlet chatData = {\n\t\tuser : game.user._id,\n\t\tcontent : message,\n\t\tblind: true,\n\t\twhisper : game.users.entities.filter(u => u.isGM).map(u => u._id)\n\t};\n\n\tChatMessage.create(chatData,{});\t\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"xMJc8qLMu8rcTJ8z"}
{"name":"5E Reroll Bad D20 With Modifiers","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Rolls a d20. If the roll is below a 3, it rerolls the value. Adds perception total + 1 as well.\n */\n\nlet dice = new Roll('1d20 + @skills.prc.total + 1').roll();\nif (dice.total <= (4 + actor.data.data.skills.prc.total)) dice.reroll();\ndice.toMessage();\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"mFnLCLpo6IQsdmUN"}
{"name":"Chartopia Roller","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Make a roll from chartopia and output the results in the chat window.\n * If you find yourself using this macro often, please support chartopia on patreon.\n */\n\n// chart id from url. IE 19449 is the chart id in https://chartopia.d12dev.com/chart/19449/\nlet chartId = 19449;\n// only let the gm see the results. false = everyone sees in chat. true = gm whispered results.\nlet gmOnly = false;\n\n\n//////////////////////////////////\n/// Don't edit past this point ///\n//////////////////////////////////\n\nvar rootUrl = \"https://chartopia.d12dev.com/test/\";\n\nfunction roll(id) {\n  let request = new XMLHttpRequest();\n  request.open('GET', rootUrl+'dice-roll-result?chart_id='+id, true);\n\n  request.onload = function() {\n    if (request.status >= 200 && request.status < 400) {\n      // Success!\n      let whisper = !!gmOnly ? game.users.entities.filter(u => u.isGM).map(u => u._id) : '';\n\n      let chatData = {\n        user: game.user._id,\n        speaker: ChatMessage.getSpeaker(),\n        content: request.responseText,\n        whisper\n      };\n\n      ChatMessage.create(chatData, {});\n    } else {\n      // We reached our target server, but it returned an error\n      console.log(\"Server error.\");\n    }\n  };\n\n  request.onerror = function() {\n    // There was a connection error of some sort\n    console.log(\"Error getting result.\");\n  };\n\n  request.send();\n} \n\nroll(chartId);\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"fEzHEn3tGXXIRHpU"}
{"name":"Roll Ammunition Die","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/*\nAuthor: stan#1549 (github.com/janssen-io)\n\nDescription:\nRoll cascading dice instead of keeping track of ammunition.\nExample:\n  When you shoot ammunition, roll a d12. On a 1, it gets replaced with a d10.\n  All the way down to a d4, after which you have a single shot left.\n  On average this gives 12 + 10 + 8 + 6 + 4 + 1 = 41 shots (for a d12)\n  If you need more than 61 shots (d20), then equip a second piece of the same\n  ammunition and give it its own ammo die.\n*/\n\n(() => {\n  if (!token) {\n    ui.notifications.warn(\"No character selected!\");\n    return;\n  }\n\n  const dieMap = {\n    20: 12,\n    12: 10,\n    10: 8,\n    8: 6,\n    6: 4,\n    4: 1,\n    1: 0\n  }\n\n  function rollDie(html, ammo) {\n    const ammoId = html[0].querySelector('input:checked')?.value;\n    if (!ammoId) {\n      ui.notifications.error(\"No ammunition selected.\");\n      return;\n    }\n    const diceInputs = Array.from(html[0].querySelectorAll('input[type=number]'));\n    const dice = diceInputs.reduce((curr, input) => (curr[input.name] = input.value, curr), {});\n\n    const die = dice[ammoId];\n    const roll = new Roll(`1d${die}`);\n    roll.roll();\n    dice[ammoId] = roll.result == 1 ? (dieMap[die] || die - 1) : die;\n    token.actor.unsetFlag('world', 'ammunition-dice')\n      .then(entity => entity.setFlag('world', 'ammunition-dice', dice));\n    roll.toMessage({\n      flavor: `[Ammunition roll] ${token.name} fires a(n) ${ammo.find(a => a.id == ammoId).name}!`\n    });\n  }\n\n  function updateDice(html) {\n    const diceInputs = Array.from(html[0].querySelectorAll('input[type=number]'));\n    const dice = diceInputs.reduce((curr, input) => (curr[input.name] = input.value, curr), {});\n\n    token.actor.unsetFlag('world', 'ammunition-dice')\n      .then(entity => entity.setFlag('world', 'ammunition-dice', dice));\n  }\n\n  function createForm(ammo, dice) {\n    const options = ammo.map(item => `\n      <tr>\n        <td><input type=\"radio\" name=\"item\" value=\"${item.id}\" checked /></td>\n        <td>${item.name}</td>\n        <td>d<input type=\"number\" name=\"${item.id}\" value=\"${dice[item.id] || 12}\" min=\"1\" max=\"20\" required ${game.user.isGM ? '' : 'disabled'}/></td>\n      </td>\n      `);\n    return `<table><thead><tr><td></td><td>Ammunition</td><td>Die</td></tr></thead>${options.join('')}</table>`;\n  }\n\n  function createDialog(token) {\n    const dice = token.actor.getFlag('world', 'ammunition-dice') || {};\n    const ammunition = token.actor.items.filter(i => i.type == \"consumable\" && i.data.data.consumableType == \"ammo\");\n\n    if (ammunition.length === 0) {\n      ui.notifications.error(\"You have no ammunition.\");\n      return;\n    }\n\n    const form = createForm(ammunition, dice);\n\n    return new Dialog({\n      title: \"Roll ammunition die\",\n      content: form,\n      buttons: {\n        yes: { label: \"Roll\", callback: html => rollDie(html, ammunition) },\n        no: (game.user.isGM ? { label: \"Update\", callback: html => updateDice(html) } : { label: \"Cancel\" })\n      },\n      default: (game.user.isGM ? 'no' : 'yes')\n    }).render(true);\n  }\n\n  createDialog(token);\n\n})();\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"GbfsxR8dVRUtQYG0"}
