{"_id":"9TsgblYH0WTlDE9S","name":"Stealth Check (shawndibble)","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"chat","flags":{},"scope":"global","command":"// getting all actors of selected tokens\nlet actors = canvas.tokens.controlledTokens.map(({ actor }) => actor);\n\n// if there are no selected tokens, roll for the player's character.\nif (actors.length < 1) {\n  actors = game.users.entities.map(entity => {\n    if (entity.active && entity.character !== null) {\n      return entity.character;\n    }\n  });\n}\nconst validActors = actors.filter(actor => actor != null);\n\nlet messageContent = 'pp = passive perception<br>';\n\n// roll for every actor\nfor (const selectedActor of validActors) {\n  const stealthMod = selectedActor.data.data.skills.ste.mod; \n  const stealth = new Roll(`1d20+${stealthMod}`).roll().total; \n  messageContent += `<hr><h3>${selectedActor.name} stealth roll was a <b>${stealth}</b>.</h3>`;\n\n  // grab a list of unique tokens then check their passive perception against the rolled stealth.\n  const uniqueActor = {};\n  const caughtBy = canvas.tokens.placeables\n    .filter((token) => { // filter out duplicate token names. ie: we assume all goblins have the same passive perception\n      if (!token.actor || uniqueActor[token.actor.name]) {\n        return false;\n      }\n      uniqueActor[token.actor.name] = true;\n      return true;\n    })\n    .filter(token => {\n      return selectedActor.id !== token.actor.id; // Don't check to see if the token sees himself.\n    })\n    .filter(({ actor }) => actor.data.data.skills.prc.passive >= stealth); // check map tokens passives with roller stealth\n\n  if (!caughtBy.length) {\n    messageContent += 'Stealth successful!<br>';\n  } else {\n    messageContent += 'Stealth questionable:<br>';\n    caughtBy.map(({ actor }) => {\n      messageContent += `<b>${actor.name}</b> pp(${actor.data.data.skills.prc.passive}).<br>`;\n    });\n  }\n}\n\n// create the message\nconst chatData = {\n  user: game.user._id,\n  speaker: game.user,\n  content: messageContent,\n  whisper: game.users.entities.filter((u) => u.isGM).map((u) => u._id),\n};\nChatMessage.create(chatData, {});\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Wandering Monsters (Valien)","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"chat","flags":{},"scope":"global","command":"// setting variables\nlet msgContent = 'Wandering Monster roll was: ';\nlet result = '';\n\n// roll to check for wandering monster\nresult = new Roll(`1d20`).roll().total;\n\n// create the message\nif(result !== '') {\n  let chatData = {\n    content: msgContent + result,\n    whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n  };\n  ChatMessage.create(chatData, {});\n}\n\n// This requires you to have an existing Table built in Foundry VTT. Replace the table name below with your table name.\n// In this example, a roll between 17-20 will generate a roll from the Table. Tweak as needed!\nif (result >= 17) {\n  const table = game.tables.entities.find(t => t.name === \n  \"Wandering Monsters\");\n  table.draw();\n}","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"DKxkQhiyOQMCCcGG"}
{"name":"Roll Table (Reaver01)","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"chat","flags":{},"scope":"global","command":"// Simple macro example to only roll from a table and whisper the result to the DM\n\nconst table = game.tables.entities.find(t => t.name === \"name of your table\");\nlet roll = table.roll();\n\nlet chatData = {\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker(),\n    content: roll[1].text,\n    whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n};\nChatMessage.create(chatData, {});","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"GgFydAwlZwXQocph"}
{"name":"Roll Initiatives (shawndibble)","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"chat","flags":{},"scope":"global","command":"/**\n * Takes all selected tokens and adds them to the combat tracker. Then rolls initative for all NPC tokens.\n */\n\nasync function start() {\n  for ( let token of canvas.tokens.controlled) {      \n    if (token.inCombat === false){\n      // Change 'rollNPC' to 'rollAll' if you want to roll for your players as well.\n      await token.toggleCombat().then(() => game.combat.rollNPC(null, {rollMode: 'gmroll'}));\n    }\n  }\n}\n\nstart();","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"ZaiiiR9KPBfzHvea"}
