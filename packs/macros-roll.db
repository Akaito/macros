{"_id":"9TsgblYH0WTlDE9S","name":"Stealth Check","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Grabs selected tokens and rolls a stealth check against all other tokens passive perception on the map. Then returns the result.\n\n// getting all actors of selected tokens\nlet actors = canvas.tokens.controlled.map(({ actor }) => actor);\n\n// if there are no selected tokens, roll for the player's character.\nif (actors.length < 1) {\n  actors = game.users.entities.map(entity => {\n    if (entity.active && entity.character !== null) {\n      return entity.character;\n    }\n  });\n}\nconst validActors = actors.filter(actor => actor != null);\n\nlet messageContent = 'pp = passive perception<br>';\n\n// roll for every actor\nfor (const selectedActor of validActors) {\n  const stealthMod = selectedActor.data.data.skills.ste.mod; // stealth roll\n  const stealth = new Roll(`1d20+${stealthMod}`).roll().total; // rolling the formula\n  messageContent += `<hr><h3>${selectedActor.name} stealth roll was a <b>${stealth}</b>.</h3>`; // creating the output string\n\n  // grab a list of unique tokens then check their passive perception against the rolled stealth.\n  const uniqueActor = {};\n  const caughtBy = canvas.tokens.placeables\n    .filter(token => !!token.actor)\n    .filter(({ actor }) => { // filter out duplicate token names. ie: we assume all goblins have the same passive perception\n      if (uniqueActor[actor.name]) {\n        return false;\n      }\n      uniqueActor[actor.name] = true;\n      return true;\n    })\n    .filter(({ actor }) => {\n      return selectedActor.id !== actor.id; // Don't check to see if the token sees himself.\n    })\n    .filter(({ actor }) => actor.data.data.skills.prc.passive >= stealth); // check map tokens passives with roller stealth\n\n  if (!caughtBy.length) {\n    messageContent += 'Stealth successful!<br>';\n  } else {\n    messageContent += 'Stealth questionable:<br>';\n    caughtBy.map(({ actor }) => {\n      messageContent += `<b>${actor.name}</b> pp(${actor.data.data.skills.prc.passive}).<br>`;\n    });\n  }\n}\n\n// create the message\nconst chatData = {\n  user: game.user._id,\n  speaker: game.user,\n  content: messageContent,\n  whisper: game.users.entities.filter((u) => u.isGM).map((u) => u._id),\n};\nChatMessage.create(chatData, {});\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"DKxkQhiyOQMCCcGG","name":"Wandering Monsters","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// setting variables\nlet tableName = \"Wandering Monsters\";\nlet msgContent = 'Wandering Monster roll was: ';\nlet result = '';\n\n// roll to check for wandering monster\nresult = new Roll(`1d20`).roll().total;\n\n// create the message\nif(result !== '') {\n  let chatData = {\n    content: msgContent + result,\n    whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n  };\n  ChatMessage.create(chatData, {});\n}\n\n// In this example, a roll between 17-20 will generate a roll from the Table. Tweak as needed!\nif (result >= 17) {\n  const table = game.tables.entities.find(t => t.name === tableName);\n  table.draw();\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"GgFydAwlZwXQocph","name":"Roll Table","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Simple macro example to only roll from a table and whisper the result to the DM\n\nconst table = game.tables.entities.find(t => t.name === \"name of your table\");\nlet roll = table.roll();\n\nlet chatData = {\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker(),\n    content: roll.results[0].text,\n    whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n};\nChatMessage.create(chatData, {});\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"ZaiiiR9KPBfzHvea","name":"Roll Initiatives","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Takes all selected tokens and adds them to the combat tracker. Then rolls initative for all NPC tokens.\n */\n\nasync function start() {\n  for ( let token of canvas.tokens.controlled) {      \n    if (token.inCombat === false){\n      // Change 'rollNPC' to 'rollAll' if you want to roll for your players as well.\n      await token.toggleCombat().then(() => game.combat.rollNPC(null, {rollMode: 'gmroll'}));\n    }\n  }\n}\n\nstart();\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"9TsgblYH0WTlDE9S","name":"Stealth Check","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Grabs selected tokens and rolls a stealth check against all other tokens passive perception on the map. Then returns the result.\n\n// getting all actors of selected tokens\nlet actors = canvas.tokens.controlled.map(({ actor }) => actor);\n\n// if there are no selected tokens, roll for the player's character.\nif (actors.length < 1) {\n  actors = game.users.entities.map(entity => {\n    if (entity.active && entity.character !== null) {\n      return entity.character;\n    }\n  });\n}\nconst validActors = actors.filter(actor => actor != null);\n\nlet messageContent = 'pp = passive perception<br>';\n\n// roll for every actor\nfor (const selectedActor of validActors) {\n  const stealthMod = selectedActor.data.data.skills.ste.total; // stealth roll\n  const stealth = new Roll(`1d20+${stealthMod}`).roll().total; // rolling the formula\n  messageContent += `<hr><h3>${selectedActor.name} stealth roll was a <b>${stealth}</b>.</h3>`; // creating the output string\n\n  // grab a list of unique tokens then check their passive perception against the rolled stealth.\n  const uniqueActor = {};\n  const caughtBy = canvas.tokens.placeables\n    .filter(token => !!token.actor)\n    .filter(({ actor }) => { // filter out duplicate token names. ie: we assume all goblins have the same passive perception\n      if (uniqueActor[actor.name]) {\n        return false;\n      }\n      uniqueActor[actor.name] = true;\n      return true;\n    })\n    .filter(({ actor }) => {\n      return selectedActor.id !== actor.id; // Don't check to see if the token sees himself.\n    })\n    .filter(({ actor }) => actor.data.data.skills.prc.passive >= stealth); // check map tokens passives with roller stealth\n\n  if (!caughtBy.length) {\n    messageContent += 'Stealth successful!<br>';\n  } else {\n    messageContent += 'Stealth questionable:<br>';\n    caughtBy.map(({ actor }) => {\n      messageContent += `<b>${actor.name}</b> pp(${actor.data.data.skills.prc.passive}).<br>`;\n    });\n  }\n}\n\n// create the message\nconst chatData = {\n  user: game.user._id,\n  speaker: game.user,\n  content: messageContent,\n  whisper: game.users.entities.filter((u) => u.isGM).map((u) => u._id),\n};\nChatMessage.create(chatData, {});\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Token HP","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Roll/Reroll selected token HP\n * Author: Tielc#7191\n */\n\nconst tokens = canvas.tokens.controlled;\nlet choice = 0;\n\nif (tokens.length > 0){\n\ttokens.forEach(rollHP);\n} else {\n\tprintMessage(\"No Tokens were selected\");\n}\n\nfunction rollHP(token, index){\n\tlet actor = token.actor;\n\tlet formula = actor.data.data.attributes.hp.formula;\n\t\t\n\tif (actor.data.type != \"npc\" || !formula) return;\n\t\n\tlet hp = new Roll(formula).roll().total;\n\t\n\tactor.data.data.attributes.hp.value = hp;\n\tactor.data.data.attributes.hp.max = hp;\n\t\n\tprintMessage('<h2>' + actor.data.name + '</h2><strong>HP:</strong> ' + actor.data.data.attributes.hp.value + '/' + actor.data.data.attributes.hp.max + '<span style=\"float:right\"><em>(' + token.data._id + ')</em></span>');\n}\n\nfunction printMessage(message){\n\tlet chatData = {\n\t\tuser : game.user._id,\n\t\tcontent : message,\n\t\tblind: true,\n\t\twhisper : game.users.entities.filter(u => u.isGM).map(u => u._id)\n\t};\n\n\tChatMessage.create(chatData,{});\t\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"xMJc8qLMu8rcTJ8z"}
