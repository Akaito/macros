{"_id":"525JVjJGyjIH5gv2","name":"Log Troubleshooting MSG To Console","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Courtesy of @fohswe\n// Logs a troubleshooting message to the browser console.\n// (You can usually view the browser console using F12.)\n\nconst gl = canvas.app.renderer.context.gl;\n\nconsole.log(\n`=== Start of troubleshooting ===\nBackground image: ${canvas.background.img.width}x${canvas.background.img.height}\nNumber of walls: ${canvas.scene.data.walls.length}\nNumber of selected vision sources: ${canvas.sight.sources.vision.size}\nNumber of light sources: ${canvas.sight.sources.lights.size}\nWebGL MAX_TEXTURE_SIZE: ${gl.getParameter(gl.MAX_TEXTURE_SIZE)}\n`\n);","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"5XA28twwaRBUFEjC","name":"Breathing Lights","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Courtesy of @ohporter\n// Cause lightsources to \"breathe,\" expanding and contracting.\n(async () => {\n    let min = 5;\n    let max = 10;\n    if (game.pulsatingLights) {\n      game.pulsatingLights = false;\n    } else {\n      game.pulsatingLights = true;\n      let glyphLights = [];\n      let glyphColor = \"#5940b5\"\n      let scene = game.scenes.active;\n  \n      canvas.lighting.placeables.forEach(l => { if (l.data.tintColor === glyphColor && l.scene === scene) glyphLights.push(l.id) })\n  \n      const updates = []\n  \n      let radius = min;\n      let increment = true;\n      let interval = setInterval(async () => {\n        glyphLights.forEach(id => {\n          updates.push({ _id: id, dim: radius, bright: radius/2});\n        })\n        await scene.updateEmbeddedEntity(\"AmbientLight\", updates);\n  \n        if (increment) {radius += 1} else {radius -= 1};\n        if (radius === max) {increment = false};\n        if (radius === min) {increment = true};\n        if (!scene.active || !game.pulsatingLights) {\n          // Reset to default glow\n          glyphLights.forEach(id => {\n            updates.push({ _id: id, dim: min, bright: 0});\n          })\n          await scene.updateEmbeddedEntity(\"AmbientLight\", updates);\n          clearInterval(interval);\n        }\n      }, 200);\n    }\n  })()","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"8iEx21HSVOmkbBFE","name":"Combat Tracker AC HP","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Adds the actor's AC to the combat tracker. Then toggles between HP and AC\nconst a = \"attributes.ac.value\";\nconst b = \"attributes.hp.value\";\n\nif (game.combat.settings.resource == a) {\n  game.settings.set('core', 'combatTrackerConfig', {resource: b, skipDefeated: true});\n} else {\n  game.settings.set('core', 'combatTrackerConfig', {resource: a, skipDefeated: true});\n}\nui.combat.updateTrackedResources();","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Toggle Playlist","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// get actual pl data from entries\nlet _playlistArray = game.playlists.entries;\nlet _applyChanges = false;\nlet _raw = `\n\n<form>\n    <div class=\"form-group\">\n        <label>Select Playlist:</label>\n        <select id=\"playlist-selection\" name=\"playlist-selection\">\n        {{#each this}}\n            <option> {{this.data.name}} </option>\n        {{/each}}\n        </select>\n    </div>\n</form>\n`\nlet _html = Handlebars.compile(_raw)\nlet d = new Dialog({\n    title: \"Playlist Toggle\",\n    content: _html(_playlistArray),\n    buttons: {\n        toggle: {\n            icon: '<i class=\"fas fa-check\"></i>',\n            label: \"Toggle Selected Playlist\",\n            callback: () => _applyChanges = true\n        },\n    },\n    default: \"toggle\",\n    close: html => {\n        if (_applyChanges) {\n            let _plName = html.find('[name=\"playlist-selection\"]')[0].value || \"none\";\n            let _pl = game.playlists.getName(_plName);\n            if (_pl.playing) {\n                // turn off\n                _pl.stopAll();\n            } else {\n                // turn on\n                _pl.playAll();\n            }\n        }\n    }\n}).render(true);\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"Cp6zQmvC9KSCEo1s"}
{"_id":"XoEEXdzERNqtAepT","name":"Open Beyond Sheet Player","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Here's one for your players if you are using Virtual Tabletop Assets - D&D Beyond Integration:\n// Requires https://www.vttassets.com/modules/vtta-dndbeyond with character sheets linked!\n\nif (!game.user.character)\n    return ui.notifications.error(\"You must first have a character assigned to your user!\");\n\nlet char = game.user.character;\n\nif (!char.data.flags.vtta && !char.data.flags.vtta.dndbeyond && !char.data.flags.vtta.dndbeyond.url)\n    return ui.notifications.error(\"Character must be linked with a D&D Beyond sheet!\");\n\nlet url = char.data.flags.vtta.dndbeyond.url;\nlet ratio = window.innerWidth / window.innerHeight;\nlet width = Math.round(window.innerWidth * 0.5);\nlet height = Math.round(window.innerWidth * 0.5 * ratio);\nconst dndBeyondPopup = window.open(\n    url,\n    \"ddb_sheet_popup\",\n    `resizeable,scrollbars,location=no,width=${width},height=${height},toolbar=1`\n);","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"bRBhm24NyQELbDti","name":"Create Chat Message","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Courtesy of @errational\n// Creates a chat message.\nconst content = `<p>Monster attacks ${controlledToken.name}</p>`;\n\nChatMessage.create({\n  speaker: ChatMessage.getSpeaker(controlledToken),\n  content: content,\n  type: CONST.CHAT_MESSAGE_TYPES.OTHER\n});","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"dgSOPUXWUK1701PV","name":"Find Lights By Color","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Courtesy of @FloRad\n// Right here's a macro that looks for lights of a certain color, \n// sets a different color and then logs out the ids of the \n// lights it previously found using the marker color\n(async () => {\n    let foundLights = [];\n    let markingColor = \"#00ff00\"\n    let newColor = \"#bbb\"\n    let scene = game.scenes.active;\n\n    canvas.lighting.placeables.forEach(l => { if (l.data.tintColor === markingColor && l.scene === scene) foundLights.push(l.id) })\n\n    const updates = []\n    foundLights.forEach(id => {\n        updates.push({ _id: id, tintColor: newColor });\n    })\n\n    await scene.updateEmbeddedEntity(\"AmbientLight\", updates);\n\n    console.log(foundLights)\n})()","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"e25oI8hASMY8bgu6","name":"Hex Crawler Helper","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/*\nRequired Rollable Tables:\n*Wilderness Encounters*\n    coast\n    jungle1\n    jungle2\n    jungle3\n    mountains\n    rivers\n    ruins\n    swamp\n    wasteland\n\n*Other Tables*\n    weather\n    directions\n\n    cache\n    deadexplorers\n\nCache and Deadexplorers are not mandatory, but if you don't want them search the file for // CACHE LINES or // DEAD EXPLORER LINES and comment out the 2 lines below the comments\n\nExplanation of those tables:\nIf you have an encounter table that has the word cache in it, the cache table will be rolled automatically.\n    <br/><span id=\"cache\">The party finds a cache: </span>\nIf you have an encounter table that has DeadExplorers in it, the dead explorer table will be rolled automatically.\n    <br/><span id=\"DeadExplorers\">The party finds: </span> \n\n\nYou can have an automatic moving \"Actual Location\" Marker by creating a Token named \"Actual Location\" and placing it on your hex grid.\nThis will move if the players are \"Lost\". If the players are not lost it will not move.\n\n\n\n*/\n\n\n// Macro requires selecting a token to roll the survival check\n\nif (canvas.tokens.controlled.length === 0)\n    return ui.notifications.error(\"Please select the token of the Navigator!\");\n\nconst playerMarker = canvas.scene.data.tokens.find(a => a.name === 'Player Location');\nconst locationMarker = canvas.scene.data.tokens.find(a => a.name === 'Actual Location');\n\nconst gridSize = canvas.grid.size;\nconst vertical = gridSize * 0.866666;\nconst diagVertical = gridSize * 0.433333;\nconst diagHorizontal = gridSize * 0.75;\n\n// The option values below are the names of your rollable tables for each hex type. If these get changed here you will need to change them in the Survival Check DC section too!\n\nlet pace = 'none';\nnew Dialog({\n    title: `Hex Crawl Helper`,\n    content: `\n    <form>\n        <div class=\"form-group\">\n            <label>Hex Type:</label>\n            <select id=\"hex-type\" name=\"hex-type\">\n                <option value=\"coast\">Coast</option>\n                <option value=\"jungle1\">Jungle: No Undead</option>\n                <option value=\"jungle2\">Jungle: Lesser Undead</option>\n                <option value=\"jungle3\">Jungle: Greater Undead</option>\n                <option value=\"mountains\">Mountains</option>\n                <option value=\"rivers\">River</option>\n                <option value=\"ruins\">Ruins</option>\n                <option value=\"swamp\">Swamp</option>\n                <option value=\"wasteland\">Wasteland</option>\n            </select>\n        </div>\n        <div class=\"form-group\">\n            <label>Travel Direction:</label>\n            <select id=\"travel-direction\" name=\"travel-direction\">\n                <option value=\"North\">North</option>\n                <option value=\"Northeast\">Northeast</option>\n                <option value=\"Southeast\">Southeast</option>\n                <option value=\"South\">South</option>\n                <option value=\"Southwest\">Southwest</option>\n                <option value=\"Northwest\">Northwest</option>\n            </select>\n        </div>\n        <div class=\"form-group\">\n            <label>Travel Type:</label>\n            <select id=\"travel-type\" name=\"travel-type\">\n                <option value=\"on-foot\">On Foot</option>\n                <option value=\"canoe\">By Canoe</option>\n            </select>\n        </div>\n    </form>\n    `,\n    buttons: {\n        slow: {\n            icon: \"<i class='fas fa-user-ninja'></i>\",\n            label: `Slow Pace`,\n            callback: () => pace = 'slow'\n        },\n        average: {\n            icon: \"<i class='fas fa-hiking'></i>\",\n            label: `Average Pace`,\n            callback: () => pace = 'average'\n        },\n        fast: {\n            icon: \"<i class='fas fa-running'></i>\",\n            label: `Fast Pace`,\n            callback: () => pace = 'fast'\n        }\n    },\n    default: \"average\",\n    close: html => {\n        // set variables\n        let hexType = html.find('[name=\"hex-type\"]')[0].value;\n        let travelType = html.find('[name=\"travel-type\"]')[0].value;\n        let playerDirection = html.find('[name=\"travel-direction\"]')[0].value;\n        const weatherTable = game.tables.entities.find(t => t.name === \"weather\");\n        const directionTable = game.tables.entities.find(t => t.name === \"directions\");\n        const cacheTable = game.tables.entities.find(t => t.name === \"cache\");\n        const deadExplorerTable = game.tables.entities.find(t => t.name === \"deadexplorers\");\n        const encounterTable = game.tables.entities.find(t => t.name === hexType);\n        let weatherRoll = weatherTable.roll()[1].text;\n        let lostDirection = directionTable.roll()[1].text;\n        let msgContent = '<strong>Weather</strong> ' + weatherRoll + '<br/><br/>';\n        let navigator = Actors.instance.get(canvas.tokens.controlled[0].data.actorId);\n        let wis = navigator.data.data.abilities.wis.mod;\n        let survival = new Roll(`1d20`).roll().total + wis;\n        let slowPace = new Roll(`1d4`).roll().total;\n        let fastPace = new Roll(`1d2`).roll().total;\n        let hexesMoved = 1;\n        let encounter = '';\n        let hexText = 'hexes';\n\n        if (travelType === 'canoe') {\n            hexesMoved++;\n        }\n\n        // build pace message and hex movement\n        if (pace === 'slow') {\n            if (slowPace === 1)\n                hexesMoved--;\n            if (hexesMoved === 1)\n                hexText = 'hex';\n            msgContent += '<strong>Slow pace:</strong> Can hide from encounters or approach stealthily.<br/><br/><strong>Party can move:</strong> ' + hexesMoved + ' ' + hexText + '.<br/><br/>';\n            survival += 5;\n        } else if (pace === 'average') {\n            if (hexesMoved === 1)\n                hexText = 'hex';\n            msgContent += '<strong>Average pace:</strong> For rivers, upstream and downstream have no effect, and waterfalls occur every 10 to 20 miles (requiring portage of canoes).<br/><br/><strong>Party can move:</strong> ' + hexesMoved + ' ' + hexText + '.<br/><br/>';\n        } else if (pace === 'fast') {\n            if (fastPace === 1)\n                hexesMoved++;\n            if (hexesMoved === 1)\n                hexText = 'hex';\n            msgContent += '<strong>Fast pace:</strong> -5 to passive Perception.<br/><br/><strong>Party can move:</strong> ' + hexesMoved + ' ' + hexText + '.<br/><br/>';\n            survival -= 5;\n        } else {\n            return;\n        }\n\n        // Survival Check DC for each hex type. If selected token rolls under DC the party is lost!\n        if (((hexType === 'coast' || hexType === 'ruins') && survival < 10) || ((hexType === 'jungle1' || hexType === 'jungle2' || hexType === 'jungle3' || hexType === 'mountains' || hexType === 'rivers' || hexType === 'swamp' || hexType === 'wasteland') && survival < 15)) {\n            msgContent += '<strong>Party is Lost:</strong> Move actual location ' + hexesMoved + ' ' + hexText + ' to the ' + lostDirection + '<br/><br/>';\n            if (locationMarker) {\n                const locToken = canvas.tokens.get(locationMarker._id);\n                switch (lostDirection) {\n                    case 'South':\n                        locToken.update({\n                            x: locToken.x,\n                            y: locToken.y + (vertical * hexesMoved)\n                        });\n                        break;\n\n                    case 'Southwest':\n                        locToken.update({\n                            x: locToken.x - (diagHorizontal * hexesMoved),\n                            y: locToken.y + (diagVertical * hexesMoved)\n                        });\n                        break;\n\n                    case 'Southeast':\n                        locToken.update({\n                            x: locToken.x + (diagHorizontal * hexesMoved),\n                            y: locToken.y + (diagVertical * hexesMoved)\n                        });\n                        break;\n\n                    case 'North':\n                        locToken.update({\n                            x: locToken.x,\n                            y: locToken.y - (vertical * hexesMoved)\n                        });\n                        break;\n\n                    case 'Northwest':\n                        locToken.update({\n                            x: locToken.x - (diagHorizontal * hexesMoved),\n                            y: locToken.y - (diagVertical * hexesMoved)\n                        });\n                        break;\n\n                    case 'Northeast':\n                        locToken.update({\n                            x: locToken.x + (diagHorizontal * hexesMoved),\n                            y: locToken.y - (diagVertical * hexesMoved)\n                        });\n                        break;\n\n                    default:\n                        break;\n                }\n            }\n            if (playerMarker) {\n                const playerToken = canvas.tokens.get(playerMarker._id);\n                switch (playerDirection) {\n                    case 'South':\n                        playerToken.update({\n                            x: playerToken.x,\n                            y: playerToken.y + (vertical * hexesMoved)\n                        });\n                        break;\n\n                    case 'Southwest':\n                        playerToken.update({\n                            x: playerToken.x - (diagHorizontal * hexesMoved),\n                            y: playerToken.y + (diagVertical * hexesMoved)\n                        });\n                        break;\n\n                    case 'Southeast':\n                        playerToken.update({\n                            x: playerToken.x + (diagHorizontal * hexesMoved),\n                            y: playerToken.y + (diagVertical * hexesMoved)\n                        });\n                        break;\n\n                    case 'North':\n                        playerToken.update({\n                            x: playerToken.x,\n                            y: playerToken.y - (vertical * hexesMoved)\n                        });\n                        break;\n\n                    case 'Northwest':\n                        playerToken.update({\n                            x: playerToken.x - (diagHorizontal * hexesMoved),\n                            y: playerToken.y - (diagVertical * hexesMoved)\n                        });\n                        break;\n\n                    case 'Northeast':\n                        playerToken.update({\n                            x: playerToken.x + (diagHorizontal * hexesMoved),\n                            y: playerToken.y - (diagVertical * hexesMoved)\n                        });\n                        break;\n\n                    default:\n                        break;\n                }\n            }\n        } else {\n            if (playerMarker && locationMarker) {\n                const locToken = canvas.tokens.get(locationMarker._id);\n                const playerToken = canvas.tokens.get(playerMarker._id);\n\n                switch (playerDirection) {\n                    case 'South':\n                        playerToken.update({\n                            x: locToken.x,\n                            y: locToken.y + (vertical * hexesMoved)\n                        });\n                        locToken.update({\n                            x: locToken.x,\n                            y: locToken.y + (vertical * hexesMoved)\n                        });\n                        break;\n\n                    case 'Southwest':\n                        playerToken.update({\n                            x: locToken.x - (diagHorizontal * hexesMoved),\n                            y: locToken.y + (diagVertical * hexesMoved)\n                        });\n                        locToken.update({\n                            x: locToken.x - (diagHorizontal * hexesMoved),\n                            y: locToken.y + (diagVertical * hexesMoved)\n                        });\n                        break;\n\n                    case 'Southeast':\n                        playerToken.update({\n                            x: locToken.x + (diagHorizontal * hexesMoved),\n                            y: locToken.y + (diagVertical * hexesMoved)\n                        });\n                        locToken.update({\n                            x: locToken.x + (diagHorizontal * hexesMoved),\n                            y: locToken.y + (diagVertical * hexesMoved)\n                        });\n                        break;\n\n                    case 'North':\n                        playerToken.update({\n                            x: locToken.x,\n                            y: locToken.y - (vertical * hexesMoved)\n                        });\n                        locToken.update({\n                            x: locToken.x,\n                            y: locToken.y - (vertical * hexesMoved)\n                        });\n                        break;\n\n                    case 'Northwest':\n                        playerToken.update({\n                            x: locToken.x - (diagHorizontal * hexesMoved),\n                            y: locToken.y - (diagVertical * hexesMoved)\n                        });\n                        locToken.update({\n                            x: locToken.x - (diagHorizontal * hexesMoved),\n                            y: locToken.y - (diagVertical * hexesMoved)\n                        });\n                        break;\n\n                    case 'Northeast':\n                        playerToken.update({\n                            x: locToken.x + (diagHorizontal * hexesMoved),\n                            y: locToken.y - (diagVertical * hexesMoved)\n                        });\n                        locToken.update({\n                            x: locToken.x + (diagHorizontal * hexesMoved),\n                            y: locToken.y - (diagVertical * hexesMoved)\n                        });\n                        break;\n\n                    default:\n                        break;\n                }\n            }\n        }\n\n        msgContent += '<strong>Morning Encounter:</strong> ';\n\n        if (new Roll(`1d20`).roll().total > 15) {\n            encounter = encounterTable.roll()[1].text;\n            msgContent += encounter;\n            // CACHE LINES comment out the next 2 lines if you don't want to use a cache table!\n            if (encounter.indexOf('cache') > -1)\n                msgContent += cacheTable.roll()[1].text + '<br/><br/>';\n            // DEAD EXPLORER LINES comment out the next 2 lines if you don't want to use a dead explorer table!\n            if (encounter.indexOf('DeadExplorers') > -1)\n                msgContent += deadExplorerTable.roll()[1].text + '<br/><br/>';\n            msgContent += '<strong>Afternoon Encounter:</strong> ';\n        } else {\n            msgContent += 'None.<br/><br/><strong>Afternoon Encounter:</strong> ';\n        }\n\n        if (new Roll(`1d20`).roll().total > 15) {\n            encounter = encounterTable.roll()[1].text;\n            msgContent += encounter;\n            // CACHE LINES comment out the next 2 lines if you don't want to use a cache table!\n            if (encounter.indexOf('cache') > -1)\n                msgContent += cacheTable.roll()[1].text + '<br/><br/>';\n            // DEAD EXPLORER LINES comment out the next 2 lines if you don't want to use a dead explorer table!\n            if (encounter.indexOf('DeadExplorers') > -1)\n                msgContent += deadExplorerTable.roll()[1].text + '<br/><br/>';\n            msgContent += '<strong>Evening Encounter:</strong> ';\n        } else {\n            msgContent += 'None.<br/><br/><strong>Evening Encounter:</strong> ';\n        }\n\n        if (new Roll(`1d20`).roll().total > 15) {\n            encounter = encounterTable.roll()[1].text;\n            msgContent += encounter;\n            // CACHE LINES comment out the next 2 lines if you don't want to use a cache table!\n            if (encounter.indexOf('cache') > -1)\n                msgContent += cacheTable.roll()[1].text + '<br/><br/>';\n            // DEAD EXPLORER LINES comment out the next 2 lines if you don't want to use a dead explorer table!\n            if (encounter.indexOf('DeadExplorers') > -1)\n                msgContent += deadExplorerTable.roll()[1].text + '<br/><br/>';\n        } else {\n            msgContent += 'None.';\n        }\n\n        // create the message\n        let chatData = {\n            content: msgContent,\n            whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n        };\n        ChatMessage.create(chatData, {});\n    }\n}).render(true);","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"fYT65nJz51J74ymJ","name":"Jukebox","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Quickly play from a list of sound effects and set their audio level. (does not loop)\n * Author: Rockshow\n */\n\nlet playlist = {\n  'twigs breaking': 'audio/twigs_1.mp3',\n  'door opening': 'sounds/lock.wav',\n};\n\nlet optionList;\nfor (let [key, value] of Object.entries(playlist)) {\n  optionList += `<option value=\"${value}\">${key}</option>`;\n}\n\nlet applyChanges = false;\nnew Dialog({\n  title: `Audio chosing form`,\n  content: `\n    <form>\n      <div class=\"form-group\">\n        <label>Canzone:</label>\n        <select id=\"idcanzone\" name=\"idcanzone\">\n          ${optionList}\n        </select>\n      </div>\n   \n        <div class=\"form-group\">\n        <label for=\"vol\">Volume:</label>\n           <div class=\"form-fields\">\n            <input type=\"range\" id=\"vol\" name=\"vol\" min=\"0\" max=\"8\" value=\"1\" step=\"0.2\" data-dtype=\"Number\">\n            <span class=\"range-value\" id=\"demo\">1</span>\n           </div>\n        </div>\n </form> \n<script>\nvar slider = document.getElementById(\"vol\");\nvar output = document.getElementById(\"demo\");\noutput.innerHTML = slider.value;\n\nslider.oninput = function() {\n  output.innerHTML = this.value;\n}\n</script>\n          `,\n  buttons: {\n    no: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancel Changes`\n        },\n    yes: {\n      icon: \"<i class='fas fa-check'></i>\",\n      label: `Apply Changes`,\n      callback: () => applyChanges = true\n         },\n           },\n  default: \"yes\",\n  close: html => {\n    if (applyChanges) {\n    let canzone= html.find('[name=\"idcanzone\"]')[0].value || \"none\";\n    let vol1= html.find('[name=\"vol\"]')[0].value || \"none\";\n    AudioHelper.play({src: canzone, volume:vol1, autoplay: true, loop: false}, true);\n                      }\n                 }\n  }).render(true);\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Share Image Via URL","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Share an image to all players when you have an image URL\n * Author: @Krishmero#1792\n */\n\nnew Dialog({\n  title: `Share Image via URL`,\n  content: `\n    <form>\n      <div class=\"form-group\">\n        <label for=\"image-url\">Image URL:</label>\n        <input type=\"text\" id=\"image-url\" name=\"image-url\" />\n      </div>\n    </form>\n  `,\n  buttons: {\n    yes: {\n      icon: \"<i class='fas fa-check'></i>\",\n      label: `Share`,\n      callback: (html) => {\n        let imageUrl = html.find('#image-url').val();\n        if (!imageUrl) {\n          return ui.notifications.info(\"You did not provide a valid image.\");\n        }\n        const ip = new ImagePopout(imageUrl);\n\n        // Display the image popout\n        ip.render(true);\n\n        // Share the image with other connected players\n        ip.shareImage();\n      }\n    },\n    no: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancel`\n    },\n  },\n  default: \"yes\"\n}).render(true)\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"mPIqhwFL3h5W9d2t"}
{"_id":"msTrIfgZGAzf9uHN","name":"Resolve Surprise","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Resolve who is surprised between groups of players and enemies or individual players and enemies\n// This macro requires The Furnance module with \"Advanced Macros\" turned on.\n// ReadMe: https://gitlab.com/x.technocat/foundry-macros/-/blob/e67f9441b2d6d442258db1d51aa2be3ead97569d/surprise-macros/README.md\n\n// Get player character tokens\nconst playerActors = getPlayerActors();\n\n// Get hostile tokens\nconst enemyActors = getEnemyActors();\n\nlet warnMsg = \"\";\n\n// Main function\nconst isSuccessful = checkSurprise(playerActors, enemyActors);\n\nif (!isSuccessful) {\n  return ui.notifications.warn(warnMsg);\n}\n\nfunction checkSurprise(playerActors, enemyActors) {\n  if (!game.user.isGM) {\n    warnMsg = \"You do not have permission to run this macro.\";\n    return false;\n  }\n  if (!playerActors.length > 0) {\n    warnMsg =\n      \"Could not find player characters in the scene. Please add player characters to the scene.\";\n    return false;\n  }\n  if (!enemyActors.length > 0) {\n    warnMsg =\n      \"Could not find hostile tokens. You need tokens with hostile dispositions in the scene to check for Surprise!\";\n    return false;\n  }\n\n  // Displays a popup and handles the input. Thanks to PaperPunk for this.\n  let calculateSurprise = false;\n\n  new Dialog({\n    title: `What Group is Sneaking?`,\n    content: `\n    <form>\n      <div>\n        <label>Select which group is sneaking/ambushing:</label><br><br>\n        <div style=\"margin:auto; width: 50%;\">\n        <input type=\"radio\" name=\"sneaking-group\" id=\"enemies\" value=\"enemies\" checked=\"checked\">\n        <label for=\"enemies\"><b>Enemy</b> is sneaking</label><br>\n        <input type=\"radio\" name=\"sneaking-group\" id=\"party\" value=\"party\">\n        <label for=\"party\"><b>Party</b> is sneaking</label><br>\n        </div>\n        <br>\n      </div>\n    </form>\n    `,\n    buttons: {\n      yes: {\n        icon: \"<i class='fas fa-check'></i>\",\n        label: `Calculate Surprise`,\n        callback: () => (calculateSurprise = true), //if \"yes\" is selected, apply the selection.\n      },\n      no: {\n        icon: \"<i class='fas fa-times'></i>\",\n        label: `Cancel Surprise`,\n      },\n    },\n    // Defaulting to yes, so that when someone selects something and hits enter, it doesn't cancel:\n    default: \"yes\",\n\n    // Handle the input\n    close: (html) => {\n      if (calculateSurprise) {\n        // Determine which group is sneaking based on the user's selection\n        const sneakyOptions = html.find('[name=\"sneaking-group\"]'); \n        let sneakingGroup;\n        for (const option of sneakyOptions) {\n          if(option.checked) {\n            sneakingGroup = option.value;\n            break;\n          }\n        }      \n\n        let results = ``;\n        let lowestStealthCheck = 0;\n\n        switch (sneakingGroup) {\n          case \"enemies\":\n            lowestStealthCheck = rollStealth(enemyActors);\n            results = calculateSurpriseResults(\n              lowestStealthCheck,\n              playerActors\n            );\n            break;\n\n          case \"party\":\n            lowestStealthCheck = rollStealth(playerActors);\n            results = calculateSurpriseResults(\n              lowestStealthCheck, \n              enemyActors);\n            break;\n        }\n\n        handleChatMessage(results, lowestStealthCheck);\n      }\n    },\n  }).render(true); // display pop up window\n\n  return true; // no issues and we're done here!\n}\n\nfunction handleChatMessage(results, lowestStealth) {\n  let messageContent = ``;\n  messageContent += `<b>Lowest Stealth: </b> [[${lowestStealth}]] <br><br>`;\n  messageContent += results;\n\n  const surpriseRules =\n    \"<br><b>Surprise Rules</b><br>\" +\n    \"Compare the Dexterity (Stealth) checks of anyone hiding with the passive Wisdom (Perception) score of each creature on the opposing side. Any character or monster that doesn't notice <i><b>a</b></i> threat is surprised at the start of the encounter. <br><br>\" +\n    \"If you're surprised, you can't move or take an action on your first turn of the combat, and you can't take a reaction until that turn ends. A member of a group can be surprised even if the other members aren't.<br><br> <i>PHB. 189</i>\";\n\n  messageContent += surpriseRules;\n\n  let chatData = {\n    user: game.user._id,\n    speaker: game.user.name,\n    content: messageContent,\n    whisper: game.users.entities.filter((u) => u.isGM).map((u) => u._id),\n  };\n\n  ChatMessage.create(chatData, {});\n}\n\nfunction getPlayerActors() {\n  // Get tokens in the scene that are player characters and not NPCs. Prioritize selected tokens.\n  const controlledPlayerActors = canvas.tokens.controlled\n    .filter((pc) => pc.actor.isPC && pc.actor.data.type === \"character\")\n    .map((a) => a.actor);\n\n  if (controlledPlayerActors.length > 0) {\n    return controlledPlayerActors;\n  }\n\n  // If none are selected, use all the player characters in the scene\n  return canvas.tokens.children[0].children\n    .filter((pc) => pc.actor.isPC && pc.actor.data.type === \"character\")\n    .map((a) => a.actor);\n}\n\nfunction getEnemyActors() {\n  // Prioritize selected hostile enemies\n  const controlledEnemyActors = canvas.tokens.controlled\n    .filter((ec) => ec.actor.isPC === false && ec.data.disposition === -1)\n    .map((a) => a.actor);\n\n  if (controlledEnemyActors.length > 0) {\n    return controlledEnemyActors;\n  }\n\n  // If none are selected, use all the enemies in the scene that are hostile\n  return canvas.tokens.children[0].children\n    .filter((ec) => ec.actor.isPC === false && ec.data.disposition === -1)\n    .map((a) => a.actor);\n}\n\nfunction rollStealth(sneakyGroup) {\n  // Roll stealth for the sneaking group\n  let stealthResults = [];\n  for (let actor of sneakyGroup) {\n    let stealth =\n      new Roll(\"1d20\").roll().total + actor.data.data.skills.ste.mod;\n    stealthResults.push(stealth);\n  }\n\n  // Return the lowest stealth roll, it's all we need\n  return Math.min(...stealthResults);\n}\n\nfunction calculateSurpriseResults(lowestStealth, perceptiveGroup) {\n  let resultMsg = ``;\n\n  const surprisedTxt = `[<span style=\"color:red\">Surprised</span>]`;\n  const notSurprisedTxt = `[<span style=\"color:green\">Not Surprised</span>]`;\n  const alertTxt = `<i>Alert</i>`;\n\n  const lowestPerception = Math.min.apply(\n    Math,\n    perceptiveGroup.map(function (actor) {\n      return actor.data.data.skills.prc.passive;\n    })\n  );\n\n  if (lowestPerception >= lowestStealth) {\n    resultMsg += `<i>No one is Surprised!</i> <br>`;\n  } else {\n    for (let actor of perceptiveGroup) {\n      const name = actor.data.name;\n      const prc = actor.data.data.skills.prc.passive;\n      let msg = ``;\n\n      // If Alert feat not surprised, else if win perception not surprised, else surprised\n      const alertFeat = actor.data.items.find((p) => p.name === \"Alert\");\n      if (alertFeat) {\n        msg = `${name} (${prc}) -- ${notSurprisedTxt} ${alertTxt}`;\n      } else if (prc >= lowestStealth) {\n        msg = `${name} (${prc}) -- ${notSurprisedTxt}`;\n      } else {\n        msg = `${name} (${prc}) -- ${surprisedTxt}`;\n      }\n\n      // Append this actor's surprise result to chat message variable.\n      resultMsg += `${msg} <div style=\"border-bottom: 1px solid gray\"></div> <br>`;\n    }\n  }\n\n  return resultMsg;\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"qlx6N8QD6QliPQbu","name":"Create Ambient Light","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Create a (pre-configured) lightsource on the current scene. \n// This example is a blue light for \"activating a stargate.\"\n\nAmbientLight.create({\n  t: \"l\", // l for local. The other option is g for global.\n  x: 1100, // horizontal positioning\n  y: 1150, // vertical positioning\n  dim: 20.50, // the total radius of the light, including where it is dim.\n  bright: 19.00, // the bright radius of the light\n  angle: 360, // the coverage of the light. (Try 30 for a \"spotlight\" effect.)\n  rotation: 0, // the beam direction of the light in degrees (if its angle is less than 360 degrees.) \n               // Oddly, degrees are counted from the 6 o'clock position.\n  tintColor: \"#0080FF\", // Light coloring.\n  tintAlpha: 0.5 // Light opacity (or \"brightness,\" depending on how you think about it.) \n});","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"r8G0g61ikT9mJJwF","name":"Move Walls","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/* From: @(Busy) Gen Kitty (she/her)\nTo move each node on both axes, you need all 4 parameters listed. \nIn this case, he wanted to move all the walls up and to the left and \nthe foundry grid is sorta vertically flipped to what you'd expect, \nwhich is why all of the operators are \"-=\" If you wanted to move them \nin different directions it'd just be a matter of changing the operator \nnext to the equals sign.\nEach argument is a node's X or Y position, and each wall segment has two nodes. \n0 = Node 1 X \n1 = Node 1 Y \n2 = Node 2 X \n3 = Node 2 Y\n*/\n\nlet walls = canvas.scene.data.walls.map(w => {\n  w = duplicate(w);\n  w.c[0] -= 50;\n  w.c[1] -= 50;\n  w.c[2] -= 50;\n  w.c[3] -= 50;\n  return w;\n});\ncanvas.scene.update({walls: walls});","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Recursive Folder Permissions","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"var folderName = \"FOLDER NAME HERE\";\nvar desiredPermission = 0; // 0=None, 1=Limited, 2=Observer, 3=Owner\nvar applyInSubfolders = true;\n \n/*****\nWARNING: This will overwrite the permissions of the items in the folder <folderName>!\n         That is, it will not keep the player permissions!\n       \n* * * * * * * * * * * * * * * * * * * * * *\n       \nWARNING: Make sure the folder name is unique across actors, scenes, items, journals and roll tables!\n         This script will apply the desired permission on the first folder it finds with that name.\n******/\n \nfunction repermission(currentFolder) {\n  console.log(\"Repermissioning: \", currentFolder.name);\n \n  if (currentFolder.content){\n    currentFolder.content.map(item => {\n      let newPermissions = duplicate(item.data.permission);\n      newPermissions.default = desiredPermission;\n      console.log(\"  Item:\", item.data.name);\n      item.update({permission: newPermissions});\n    });\n  }\n \n  if (currentFolder.children && applyInSubfolders) {\n    currentFolder.children.map(({data}) => {\n      repermission(game.folders.entities.filter(f => f.data._id == data._id)[0]);\n    });\n  }\n}\n \nfunction findFolder(parent) {\n  if (parent.data.name === folderName) {\n    return parent;\n  }\n \n  for (let child of parent.children) {\n    let foundFolder = findFolder(child);\n    if (foundFolder) {\n      return foundFolder;\n    }\n  }\n \n  return null;\n}\n \nif (game.folders.entities.length == 0) {\n    console.error(\"Your world does not have any folders.\");\n}\n \nvar root = { data: {}, children: game.folders.entities };\n \nvar folder = findFolder(root);\nif (!folder) {\n  console.error(`Your world does not have any folders named '${folderName}'.`);\n}\nelse {\n  repermission(folder);\n  console.log(\"Repermissioning finished successfully!\");\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"rQWMtl7Lae9LxXxx"}
{"_id":"wosXzUFEMQLD84so","name":"Ambient Light Quick Edit","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"let macroName = \"AmbientLight QuickEditor\"\nlet macroEndLog = \"---------------------------------------------\"\n\nlet i=0;\nlet lights = canvas.lighting.objects.children;\nlet lightSelected = lights[0];\nlet selectOptions = \"\";\nlet lightSelectedAngle = 0;\nlet lightSelectedBright = 0;\nlet lightSelectedDim = 0;\nlet lightSelectedRotation = 0;\nlet lightSelectedTintAlpha = 1;\nlet lightSelectedTintColor = \"\";\n\nconsole.log(\"---------------------------------------------\");\nconsole.log(`${macroName} by PaperPunk`);\nconsole.log(\"---------------------------------------------\");\nconsole.log(`${macroName} | Start`);\n\nconst drawingDetails = {\n      author: game.user._id,\n      fillAlpha: 0,\n      fillColor: \"#808080\",\n      fillType: 1,\n      fontFamily: \"FontAwesome\",\n      fontSize: 24,\n      height: 48,\n      hidden: false,\n      locked: false,\n      rotation: 0,\n      strokeAlpha: 1,\n      strokeColor: \"#000000\",\n      strokeWidth: 2,\n      text: i,\n      textAlpha: 1,\n      textColor: \"#ffffff\",\n      type: \"r\",\n      width: 48,\n      //x: 250,\n      x: lightSelected.x-24,\n      //y: 250\n      y: lightSelected.y+25\n};\n\n//let d = Drawing.create(drawingDetails);\n//d.update({\"x\": lights[i].x-24, \"y\": lights[i].y+25, \"text\": i});\n\nfor (i= 0; i< lights.length; i++) {\n selectOptions += `<option value=\"${i}\">AmbientLight ${i}</option>`;\n}\n\nconst htmlLightSelection = `\n    <form>\n      <h2>Select your light.</h2>\n      <div class=\"form-group\">\n        <label>Light:</label>\n        <select id=\"light-selector\" name=\"light-selector\">\n          ${selectOptions}\n        </select>\n      </div>\n    </form>\n    `;\n\nlet dialogSelector = new Dialog({\n  title: `${macroName}`,\n  content: htmlLightSelection,\n  buttons: {\n    confirm: {\n      icon: \"<i class='fas fa-tick'></i>\",\n      label: `Confirm`,\n      callback: htmlLightSelection => { \n        lightSelected = (htmlLightSelection.find('[name=\"light-selector\"]')[0].value)\n        lightSelectedAngle = lights[lightSelected].data.angle;\n        lightSelectedBright = lights[lightSelected].data.bright;\n        lightSelectedDim = lights[lightSelected].data.dim;\n        lightSelectedRotation = lights[lightSelected].data.rotation;\n        lightSelectedTintAlpha = lights[lightSelected].data.tintAlpha;\n        lightSelectedTintColor = lights[lightSelected].data.tintColor;\n        //console.log(`${macroName} | lightSelected = ${lightSelected}`);\n        //console.log(`${macroName} | lightSelectedBright = ${lightSelectedBright}`);\n        dialogEditor.render(true);\n      }\n    },\n    cancel: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancel`,\n      callback: () => {\n        console.log(`${macroName} | Goodbye`);\n        console.log(macroEndLog);\n      }\n    },\n  },\n  default: \"cancel\",\n  //close: () => console.log(\"AmbientLight QuickEditor | Dialog Window Closed\")\n});\n\nlet dialogEditor = new Dialog({\n  title: `${macroName}`,\n  content: `<h2>Edit your light.</h2>\n      <p>Emission Angle: ${lightSelectedAngle}</p>\n      <p>Bright light distance: ${lightSelectedBright}</p>\n      <p>Dim light distance: ${lightSelectedDim}</p>\n      <p>Rotation CW from down: ${lightSelectedRotation}</p>\n      <p>Tint Alpha: ${lightSelectedAngle}</p>\n      <p>Tint Color HexCode: ${lightSelectedAngle}</p>`,\n  buttons: {\n    rot5cw: {\n      icon: \"<i class='fas fa-redo'></i>\",\n      label: `Rotate 5* CW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot+5});\n        dialogEditor.render(true);\n      }\n    },\n    rot15cw: {\n      icon: \"<i class='fas fa-redo'></i>\",\n      label: `Rotate 15* CW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot+15});\n        dialogEditor.render(true);\n      }\n    },\n    rot45cw: {\n      icon: \"<i class='fas fa-redo'></i>\",\n      label: `Rotate 45* CW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot+45});\n        dialogEditor.render(true);\n      }\n    },\n    rot5ccw: {\n      icon: \"<i class='fas fa-undo'></i>\",\n      label: `Rotate 5* CCW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot-5});\n        dialogEditor.render(true);\n      }\n    },\n    rot15ccw: {\n      icon: \"<i class='fas fa-undo'></i>\",\n      label: `Rotate 15* CCW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot-15});\n        dialogEditor.render(true);\n      }\n    },\n    rot45ccw: {\n      icon: \"<i class='fas fa-undo'></i>\",\n      label: `Rotate 45* CCW`,\n      callback: () => { \n        let rot = lights[lightSelected].data.rotation;\n        lights[lightSelected].update({\"rotation\":rot-45});\n        dialogEditor.render(true);\n      }\n    },\n    brightup: {\n      icon: \"<i class='fas fa-circle'></i>\",\n      label: `Increase Bright by 5`,\n      callback: () => { \n        let bright = lights[lightSelected].data.bright;\n        lights[lightSelected].update({\"bright\":bright+5});\n        dialogEditor.render(true);\n      }\n    },\n    brightdown: {\n      icon: \"<i class='fas fa-circle'></i>\",\n      label: `Decrease Bright by 5`,\n      callback: () => { \n        let bright = lights[lightSelected].data.bright;\n        lights[lightSelected].update({\"bright\":bright-5});\n        dialogEditor.render(true);\n      }\n    },\n    brightoff: {\n      icon: \"<i class='fas fa-circle'></i>\",\n      label: `Remove Bright Light`,\n      callback: () => { \n        lights[lightSelected].update({\"bright\":0});\n        dialogEditor.render(true);\n      }\n    },\n    dimup: {\n      icon: \"<i class='fas fa-dot-circle'></i>\",\n      label: `Increase Dim by 5`,\n      callback: () => { \n        let dim = lights[lightSelected].data.dim;\n        lights[lightSelected].update({\"dim\":dim+5});\n        dialogEditor.render(true);\n      }\n    },\n    dimdown: {\n      icon: \"<i class='fas fa-dot-circle'></i>\",\n      label: `Decrease Dim by 5`,\n      callback: () => { \n        let dim = lights[lightSelected].data.dim;\n        lights[lightSelected].update({\"dim\":dim-5});\n        dialogEditor.render(true);\n      }\n    },\n    dimoff: {\n      icon: \"<i class='fas fa-dot-circle'></i>\",\n      label: `Remove Dim Light`,\n      callback: () => { \n        lights[lightSelected].update({\"dim\":0});\n        dialogEditor.render(true);\n      }\n    },\n    emit15: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 15*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":15});\n        dialogEditor.render(true);\n      }\n    },\n    emit45: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 45*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":45});\n        dialogEditor.render(true);\n      }\n    },\n    emit90: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 90*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":90});\n        dialogEditor.render(true);\n      }\n    },\n    emit180: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 180*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":180});\n        dialogEditor.render(true);\n      }\n    },\n    emit270: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 270*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":270});\n        dialogEditor.render(true);\n      }\n    },\n    emit360: {\n      icon: \"<i class='fas fa-rss'></i>\",\n      label: `Emission Angle 360*`,\n      callback: () => { \n        lights[lightSelected].update({\"angle\":360});\n        dialogEditor.render(true);\n      }\n    },\n    back: {\n      icon: \"<i class='fas fa-reply'></i>\",\n      label: `Back`,\n      callback: () => dialogSelector.render(true)\n    },\n    close: {\n      icon: \"<i class='fas fa-tick'></i>\",\n      label: `Close`\n    },\n  },\n  default: \"close\",\n  close: () => {\n    console.log(`${macroName} | Goodbye`);\n    console.log(macroEndLog);\n  }\n});\n\ndialogSelector.render(true);\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
