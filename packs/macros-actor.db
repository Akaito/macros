{"name":"Random Cutting Words","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Courtesy of @Zarek\n// Selected target receives a random cutting word from a table called \"Mockeries\" along with the roll reduction.\n\nif (!actor) {\n  ui.notifications.warn(\"You must have an actor selected.\");\n  return\n}\n\n// Setup variables\nlet actorLevels = actor.data.data.levels || 1;\nlet tableName = \"Mockeries\";\nlet table = game.tables.entities.find(t => t.name == tableName);\nlet mockery = \"Now go away or I shall taunt you a second time-a!\";\n\n// Get Targets name\nconst targetId = game.user.targets.ids[0];\nconst targetToken = canvas.tokens.get(targetId);\nif (!targetToken) {\n  ui.notifications.warn(\"You must target a token.\");\n  return\n}\nconst targetName = targetToken.name;\n\n// Roll the result, and mark it drawn\nif (table) {\n  if (checkTable(table)) {\n    let roll = table.roll();\n    let result = roll.results[0];\n    mockery = result.text;\n    table.updateEmbeddedEntity(\"TableResult\", {\n      _id: result._id,\n      drawn: true\n    });\n  }\n}\n\nfunction checkTable(table) {\n  let results = 0;\n  for (let data of table.data.results) {\n    if (!data.drawn) {\n      results++;\n    }\n  }\n  if (results < 1) {\n    table.reset();\n    ui.notifications.notify(\"Table Reset\")\n    return false\n  }\n  return true\n}\n\nlet dieType = 'd6';\nif (actorLevels >= 15) {\n  dieType = 'd12';\n} else if (actorLevels >= 10) {\n  dieType = 'd10';\n} else if (actorLevels >= 5) {\n  dieType = 'd8';\n}\n\nlet messageContent = `<p>${targetName} Reduce your roll by: <b>[[1${dieType}]]</b>.</p>`\nmessageContent += `<p>${token.name} exclaims <b><i>\"${mockery}\"</i></b></p>`\nmessageContent += `<details closed=\"\"><summary><a>Cutting Words</a></summary>\n<p>When a creature that you can see within 60 feet of you makes an <b>Attack roll, an ability check, or a damage roll</b>, you can use your <b>Reaction</b> to expend one of your uses of <b>Bardic Inspiration</b>,\nrolling a Bardic Inspiration die and subtracting the number rolled from the creature’s roll.</p>\n<p>You can choose to use this feature after the creature makes its roll, but before the GM determines whether the Attack roll or ability check succeeds or fails, or before the creature deals its damage. \nThe creature is immune if it can’t hear you or if it’s immune to being <b>Charmed</b>.</p></details>`\n\n// create the message\nif (messageContent !== '') {\n  let chatData = {\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker(),\n    content: messageContent,\n  };\n  ChatMessage.create(chatData, {});\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"Fa1wGSaq5J1GArjB"}
{"_id":"USJZMHU93aFklWYM","name":"Change Disposition","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"let applyChanges = false;\nnew Dialog({\n  title: `Token Disposition Changer`,\n  content: `\n    <form>\n      <div class=\"form-group\">\n        <label>Disposition Type:</label>\n        <select id=\"dispo-type\" name=\"dispo-type\">\n          <option value=\"nochange\">No Change</option>\n          <option value=\"hostile\">Hostile</option>\n          <option value=\"neutral\">Neutral</option>\n          <option value=\"friendly\">Friendly</option>\n        </select>\n      </div>\n    </form>\n    `,\n  buttons: {\n    yes: {\n      icon: \"<i class='fas fa-check'></i>\",\n      label: `Apply Changes`,\n      callback: () => applyChanges = true\n    },\n    no: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancel Changes`\n    },\n  },\n  default: \"yes\",\n  close: html => {\n    if (applyChanges) {\n      for ( let token of canvas.tokens.controlled ) {\n        let dispoType = html.find('[name=\"dispo-type\"]')[0].value || \"none\";\n        switch (dispoType) {\n          case \"hostile\":\n            token.update({\"disposition\": -1});\n            break;\n          case \"friendly\":\n            token.update({\"disposition\": 1});\n            break;\n          case \"neutral\":\n            token.update({\"disposition\": 0});\n            break;\n          case \"nochange\":\n          default:\n        }\n      }\n    }\n  }\n}).render(true);\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"ZvtYrzlv9dPpq9Pu","name":"Random Mockeries","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Courtesy of @Zarek\n// Selected target receives a random mockery from a table called \"Mockeries\" along with the DC and damage.\n\nif (!actor) {\n  ui.notifications.warn(\"You must have an actor selected.\");\n  return\n}\n\n// Setup variables\nlet actorLevels = actor.data.data.levels || 1;\nlet tableName = \"Mockeries\";\nlet table = game.tables.entities.find(t => t.name == tableName);\nlet mockery = \"Now go away or I shall taunt you a second time-a!\";\n\n// Get Targets name\nconst targetId = game.user.targets.ids[0];\nconst targetToken = canvas.tokens.get(targetId);\nif (!targetToken) {\n  ui.notifications.warn(\"You must target a token.\");\n  return\n}\nconst targetName = targetToken.name;\n\n// Roll the result, and mark it drawn\nif (table) {\n  if (checkTable(table)) {\n    let roll = table.roll();\n    let result = roll.results[0];\n    mockery = result.text;\n    table.updateEmbeddedEntity(\"TableResult\", {\n      _id: result._id,\n      drawn: true\n    });\n  }\n}\n\nfunction checkTable(table) {\n  let results = 0;\n  for (let data of table.data.results) {\n    if (!data.drawn) {\n      results++;\n    }\n  }\n  if (results < 1) {\n    table.reset();\n    ui.notifications.notify(\"Table Reset\")\n    return false\n  }\n  return true\n}\n\n// Add a message with damage roll\nlet numDie = 1;\nif (actorLevels >= 17) {\n  numDie = 4;\n} else if (actorLevels >= 11) {\n  numDie = 3;\n} else if (actorLevels >= 5) {\n  numDie = 2;\n}\n\nlet messageContent = `<p>${targetName} Roll WIS save DC [[8+${actor.data.data.abilities.cha.mod}+@attributes.prof]] or take [[${numDie}d4]] damage and have disadvantage.</p>`\nmessageContent += `<p>${token.name} exclaims <b><i>\"${mockery}\"</i></b></p>`\nmessageContent += `<details closed=\"\"><summary><a>Vicious Mockery</a></summary><p>You unleash a string of insults laced with subtle enchantments at a creature you can see within range. If the target can hear you (though it need not understand you), it must succeed on a <strong>Wisdom saving throw</strong> or take <strong>1d4 psychic damage</strong> and have <strong>disadvantage on the next attack roll</strong> it makes before the end of its next turn.</p>\n  <p>This spell’s damage increases by 1d4 when you reach 5th level ([[/r 2d4]]), 11th level ([[/r 3d4]]), and 17th level ([[/r 4d4]]).</p></details>`\n\n// create the message\nif (messageContent !== '') {\n  let chatData = {\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker(),\n    content: messageContent,\n  };\n  ChatMessage.create(chatData, {});\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"cVkN7qB4m1mRauBE","name":"Remove Conditions","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"for ( let token of canvas.tokens.controlled ){\n  await token.update({\"effects\": []});\n}","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Random Inspiration","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Courtesy of @Zarek\n// Selected target receives a random inspiration from a table called \"Inspirations\".\n\nif (!actor) {\n  ui.notifications.warn(\"You must have an actor selected.\");\n  return\n}\n\n// Get Targets name\nlet actorLevels = actor.data.data.levels || 1;\nconst targetId = game.user.targets.ids[0];\nconst targetToken = canvas.tokens.get(targetId);\nif (!targetToken) {\n  ui.notifications.warn(\"You must target a token.\");\n  return\n}\nconst targetName = targetToken.name;\n\n// Setup variables\nlet tableName = \"Inspirations\";\nlet table = game.tables.entities.find(t => t.name == tableName);\n//let inspiration = \"Cowards die many times before their deaths; the valiant never taste death but once.\";\nlet inspiration = `I don't know what effect ${targetName} will have upon the enemy, but, by God, he terrifies me.`;\n// Roll the result, and mark it drawn\nif (table) {\n  if (checkTable(table)) {\n    // let result = table.roll()[1];\n    let roll = table.roll();\n    let result = roll.results[0];\n    inspiration = result.text;\n    table.updateEmbeddedEntity(\"TableResult\", {\n      _id: result._id,\n      drawn: true\n    });\n  }\n}\n\nfunction checkTable(table) {\n  let results = 0;\n  for (let data of table.data.results) {\n    if (!data.drawn) {\n      results++;\n    }\n  }\n  if (results < 1) {\n    table.reset();\n    ui.notifications.notify(\"Table Reset\")\n    return false\n  }\n  return true\n}\n\nlet dieType = 'd6';\nif (actorLevels >= 15) {\n  dieType = 'd12';\n} else if (actorLevels >= 10) {\n  dieType = 'd10';\n} else if (actorLevels >= 5) {\n  dieType = 'd8';\n}\n\nlet messageContent = '';\nmessageContent += `<p>${token.name} exclaims <b><i>\"${inspiration}\"</i></b></p>`\nmessageContent += `<p>${targetName} is inspired.</p>`\nmessageContent += `<details closed=\"\"><summary><a>Bardic Inspiration</a></summary><p>${targetName} gains one Bardic Inspiration die, a <strong>${dieType}</strong>.<br>Once within the next 10 minutes, ${targetName} can roll the die and add the number rolled to one <b>ability check, attack roll, or saving throw</b>. ${targetName} can wait until after it rolls the <strong>d20</strong> before deciding to use the Bardic Inspiration die, but must decide before the DM says whether the roll succeeds or fails. Once the Bardic Inspiration die is rolled, it is lost.</p></details>`\n\n// create the message\nif (messageContent !== '') {\n  let chatData = {\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker(),\n    content: messageContent,\n  };\n  ChatMessage.create(chatData, {});\n}","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"devQi2BcIDhI0z1o"}
{"name":"Get Passive Perception","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// pull each player's passive perception then whisper the GM with the results.\n// author @Erogroth#7134\n\nlet actors = game.actors.entities.filter(e=> e.data.type==='character');\nlet messageContent = '';\nlet messageHeader = '<b>Passive Perception</b><br>';\nfor(let actor of actors) {\n  let modifier = actor.data.data.skills.prc.mod; // this is total bonus for perception (abilitie mod + proficiency)\n  let result = 10 + modifier; // this gives the passive perception\n  messageContent += `${actor.name} <b>${result}</b><br>`; // creating the output string\n}\n\n// create the message\nif(messageContent !== '') {\n  let chatData = {\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker(),\n    content: messageHeader + messageContent,\n    whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n  };\n  ChatMessage.create(chatData, {});\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"h7QwZjOWiLiQ4emI"}
{"_id":"hW29VmM09DenDXNz","name":"Rage","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// \tDISCLAIMER: This macro is a slightly modified version of the original masterwork written by Felix#6196.\n//\t\t\t\tOriginal version is on the wiki here: \n//\t\t\t\thttps://github.com/foundry-vtt-community/wiki/wiki/Script-Macros#rage-toggle-for-inhabited-character\n//\n//  \tDifferences in my version (Norc#5108, 05/02/2020):\n//\n//\t\tBiggest change: Changed macro to work for selected token, NOT the user's official character (game.user.character)\n//        \t        \tThis eliminated an error I was getting as a GM that prevented me from using the script.\n//\n//\t\tOther changes:  1. Fixed Rage icon toggling, for me it was backwards.\n//          \t      \t2. Added error messages for trying to rage with no token or no barbarian selected\n//\t\t\t\t\t  \t3. Added auto-bear totem detection, with a minor edit to character sheet required.\n//\n//\tChangelog: _6 05/15/2020: 1. Removed an explicit definition of Token that caused an error inside a script macro and added comments\n//\t\t\t\t     explaining how \"token\" and \"actor\" work in script macros.\n//\t\t\t\t  2. Changed \"magic words\" of the Bear Totem Spirit feature from \"Totem Spirit (Bear)\"\n//\t\t\t\t     to \"Totem Spirit: Bear\" to match VTTA importer's new support for the feature.\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tBonus Tip 1:                                                                                                                       !!!\n//!!!\tIf you chose the Spirit Seeker Primal path, and you chose the Bear totem spirit (resistance to all non-psychic damage),            !!!\n//!!!\tin your 5E character sheet, edit the name of your Totem Spirit feature to EXACTLY \"Totem Spirit: Bear\"\t\t\t\t   !!!\n//!!!   if it isn't already named that by VTTA Beyond Importer Module. This allows you to automatically gain the extra Bear Totem Spirit   !!!\n//!!!   resistances.                                                     \t\t\t\t\t\t\t\t   !!!\n//!!!                                                                                                                                      !!!\n//!!! \tBonus Tip 2:                                                                                                                       !!!\n//!!!\tIf you use the Combat Utility Belt module's Condition Lab, add a condition called Raging with the same icon as the optional rage   !!!\n//!!!\ticon overlay, 'icons/svg/explosion.svg' by default.  See OPTIONAL RAGE ICON section below.                                         !!!\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\t//declarations\n\tlet barb='';\n\tlet chatMsg='';\n\tlet bear = '';\n\tlet rageIconPath = '';\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!! \tOPTIONAL RAGE ICON - Adds this icon to your character when raging only. Comment out following line to disable (add // before)      !!!\n\n\t\trageIconPath = 'icons/svg/explosion.svg'\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\n\n//check to see if Actor exists and is a barbarian\n\n\t\t\t//Script macros automagically define \"token\" and \"actor\" for you. If you did need to manually\n\t\t\t//define it, this is how you would do so: \n\t\t\t//let actor = game.user.character;\n\nif (actor !== undefined && actor !== null) {\n    // get the barbarian class item\n    barb = actor.items.find(i => i.name === 'Barbarian');\n    if (barb == undefined) { \n        ui.notifications.warn(\"Please select a single barbarian token.\");\n    }\n \n\tif (barb !== undefined && barb !== null) {\n\t\tchatMsg = '';\n\t\tlet enabled = false;\n\t\t// store the state of the rage toggle in flags\n\t\tif (actor.data.flags.rageMacro !== null && actor.data.flags.rageMacro !== undefined) {\n\t\t\tenabled = true;\n\t\t}\n\t\t// if rage is active, disable it\n\t\tif (enabled) {\n\t\t\tchatMsg = `${actor.name} is no longer raging.`;\n\n\t\t\t// reset resistances\n\t\t\tlet obj = {};\n\t\t\tobj['flags.rageMacro'] = null;\n\t\t\tobj['data.traits.dr'] = actor.data.flags.rageMacro.oldResistances;\n\t\t\tactor.update(obj);\n\n\t\t\t// reset items\n\t\t\tfor (let item of actor.items) {\n\t\t\t\tif (item.data.flags.rageMacro !== null && item.data.flags.rageMacro !== undefined) {\n\t\t\t\t\t// restoring the old value from flags\n\t\t\t\t\tlet oldDmg = item.data.flags.rageMacro.oldDmg;\n\t\t\t\t\tlet obj = {};\n\t\t\t\t\tobj['data.damage.parts'] = oldDmg;\n\t\t\t\t\tobj['flags.rageMacro'] = null;\n\t\t\t\t\titem.update(obj);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t// if rage is disabled, enable it\n\t\t} else {\n\t\t\tchatMsg = `${actor.name} is RAAAAAGING!`;\n\n\t\t\t// update resistance\n\t\t\tlet obj = {};\n\t\t\t// storing old resistances in flags to restore later\n\t\t\tobj['flags.rageMacro.enabled'] = true;\n\t\t\tobj['flags.rageMacro.oldResistances'] = JSON.parse(JSON.stringify(actor.data.data.traits.dr));\n\n\t\t\t// add bludgeoning, piercing and slashing resistance\n\t\t\tlet newResistance = actor.data.data.traits.dr;\n\t\t\tif (newResistance.value.indexOf('bludgeoning') === -1) newResistance.value.push('bludgeoning');\n\t\t\tif (newResistance.value.indexOf('piercing') === -1) newResistance.value.push('piercing');\n\t\t\tif (newResistance.value.indexOf('slashing') === -1) newResistance.value.push('slashing');\n\n\n\t\t\t\n\t\t\t//If bear totem, add bear totem resistances.\n\t\t\tbear = actor.items.find(i => i.name === \"Totem Spirit: Bear\")\n\t\t\tif (bear !== undefined) {\n\t\t\t\tif (newResistance.value.indexOf('acid') === -1) newResistance.value.push('acid');\n\t\t\t\tif (newResistance.value.indexOf('cold') === -1) newResistance.value.push('cold');\n\t\t\t\tif (newResistance.value.indexOf('fire') === -1) newResistance.value.push('fire');\n\t\t\t\tif (newResistance.value.indexOf('force') === -1) newResistance.value.push('force');\n\t\t\t\tif (newResistance.value.indexOf('lightning') === -1) newResistance.value.push('lightning');\n\t\t\t\tif (newResistance.value.indexOf('necrotic') === -1) newResistance.value.push('necrotic');\n\t\t\t\tif (newResistance.value.indexOf('poison') === -1) newResistance.value.push('poison');\n\t\t\t\tif (newResistance.value.indexOf('radiant') === -1) newResistance.value.push('radiant');\n\t\t\t\tif (newResistance.value.indexOf('thunder') === -1) newResistance.value.push('thunder');\n\t\t\t}\n\t\t\t\n\t\t\tobj['data.traits.dr'] = newResistance;\n\t\t\tactor.update(obj);\n\n\t\t\t// update items\n\t\t\t// determining the barbarian level\n\t\t\tlet barblvl = barb.data.data.levels;\n\t\t\t// the formula to determin the rage bonus damage depending on barbarian level\n\t\t\tlet ragedmg = 2 + Math.floor(barblvl / 9) - (barblvl === 8 ? 1 : 0);\n\t\t\tfor (let item of actor.items) {\n\t\t\t\tlet isMelee = getProperty(item, 'data.data.actionType') === 'mwak';\n\t\t\t\tif (isMelee && item.data.data.damage.parts.length > 0) {\n\t\t\t\t\tconsole.log('updating ' + item);\n\t\t\t\t\tlet obj = {};\n\t\t\t\t\tlet dmg = item.data.data.damage.parts;\n\t\t\t\t\tobj['flags.rageMacro.oldDmg'] = JSON.parse(JSON.stringify(dmg));\n\t\t\t\t\tdmg[0][0] = `${dmg[0][0]} + ${ragedmg}`;\n\t\t\t\t\tobj['data.damage.parts'] = dmg;\n\t\t\t\t\titem.update(obj);\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t// toggle rage icon\n\t//  - this is optional and requires you to set the path for the token icon you want to use for rage\n\t\t\t\t//Script macros automagically define \"token\" and \"actor\" for you. If you did need to manually\n\t\t\t\t//define it, this is how you would do so: \n\t\t\t\t//let token = canvas.tokens.controlled.find(t => t.actor.id === actor.id);\n\ttoken.toggleEffect(rageIconPath);\n\t}\n\n} else ui.notifications.warn(\"Please select a token.\");\n\n// write to chat if needed:\nif (chatMsg !== '') {\n\tlet chatData = {\n\t\tuser: game.user._id,\n\t\tspeaker: ChatMessage.getSpeaker(),\n\t\tcontent: chatMsg\n    };\n\tChatMessage.create(chatData, {});\n}\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"mwiBoYVqZgJtyv9E","name":"Set Name and Bars","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"// Update all tokens on the map so that the name shows on hover and the bars always show.\n// Display Modes: ALWAYS, CONTROL, HOVER, NONE, OWNER, OWNER_HOVER\n\nconst tokens = canvas.tokens.placeables.map(token => {\n  return {\n    _id: token.id,\n    \"bar1.attribute\": \"attributes.hp\",\n    \"bar2.attribute\": \"attributes.ac.value\",\n    \"displayName\": CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER,\n    \"displayBars\": CONST.TOKEN_DISPLAY_MODES.OWNER\n  };\n});\n\ncanvas.scene.updateEmbeddedEntity('Token', tokens)","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"_id":"p0KlDQ5Ab2IIsNJY","name":"Link Actors","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"const scene = game.scenes.active;\nconst unlinked = canvas.scene.data.tokens.map(t => {\n    const actor = game.actors.entities.find(a => a.name === t.name);\n    if (actor) {\n        return {\n            _id: t._id,\n            actorId: actor.id\n        }\n    } else {\n        console.log(t.name);\n        return {\n            _id: t._id,\n            actorId: \"\"\n        }\n    }\n});\nconst updates = duplicate(unlinked);\n\nscene.updateEmbeddedEntity(\"Token\", updates);\n\nui.notifications.info('Tokens linked to actors.');\nconsole.log(updates);","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[]}
{"name":"Monk Ki","permission":{"default":0,"y5gmtwxmW3A5ZuOP":3},"type":"script","flags":{},"scope":"global","command":"/**\n * Monk Ki Point spender\n * \n * This macro will prompt which Feature you want to spend Ki points on.\n * \n * Flurry of Blows: Automatically cast two Unarmed Strike's\n * Stunning Strike: Automatically show the saving throw DC\n * Deflect Missiles: Automatically show the damage reduction\n */\n(async () => {\n    const kiName = \"Ki Points\";\n    const errNoMonkToken = \"Please select a single monk token.\";\n\n    const sendChat = async (msg) => {\n        let chatData = {\n            user: game.user.id,\n            speaker: ChatMessage.getSpeaker(),\n            content: msg,\n        };\n        ChatMessage.create(chatData, {});\n    }\n\n    if (!actor) {\n        ui.notifications.warn(errNoMonkToken);\n        return\n    }\n\n    let monk = actor.items.find(i => i.name === 'Monk' && i.type === 'class');\n    if (!monk) {\n        ui.notifications.warn(errNoMonkToken);\n        return\n    }\n\n    let monkLevels = monk.data.data.levels || 20;\n    //let subClass = monk.data.data.subclass;\n\n    if (monkLevels < 2) {\n        ui.notifications.warn('You must have a least 2 Monk levels to use ki points.');\n        return\n    }\n\n    class KiFeature {\n        /**\n         * @param {string} name\n         * @param {string} fallbackText\n         * @param {number} requireLevel\n         * @param {function} action\n         * @param {function} appendTemplate\n         * @param {number} kiCost\n         */\n        constructor(name, fallbackText, requireLevel, action, appendTemplate, kiCost) {\n            this.name = name;\n            this.fallbackText = fallbackText;\n            this.requireLevel = requireLevel;\n            this.kiCost = kiCost || 1;\n            if (action) {\n                this.action = action;\n            }\n            if (appendTemplate) {\n                this.appendTemplate = appendTemplate;\n            }\n        }\n\n        render(allowHigher) {\n            let entry = null;\n\n            const pack = game.packs.get(\"dnd5e.classfeatures\");\n            if (!pack) {\n                console.warn('Could not find \"dnd5e.classfeatures\" compendium.');\n            } else {\n                entry = pack.index.find(e => e.name === this.name);\n            }\n\n            if (!allowHigher && this.requireLevel && monkLevels && this.requireLevel > monkLevels) {\n                ui.notifications.warn(`You need to have ${this.requireLevel} monk levels, you only have ${monkLevels}.`)\n                return\n            }\n\n            if (entry) {\n                pack.getEntity(entry._id).then(o => {\n                    let template = `@Compendium[dnd5e.classfeatures.${entry._id}]{${this.name}}\n                    ${o.data.data.description.value}`;\n                    if (this.appendTemplate) {\n                        template += '\\n\\n' + this.appendTemplate();\n                    }\n                    sendChat(template);\n                    if (this.action) {\n                        this.action();\n                    }\n                });\n            } else {\n                console.warn(`Could not find \"${this.name}\" entry in compendium.`);\n                let template = this.fallbackText;\n                if (this.appendTemplate) {\n                    template += '\\n\\n' + this.appendTemplate();\n                }\n                sendChat(template);\n                if (this.action) {\n                    this.action();\n                }\n            }\n        }\n    }\n\n   const openHand = !!actor.items.find(o => o.data.name === 'Open Hand Technique') ? `<br />In addition, you can impose one of the following: <ul><li>It must succeed on a <b>Dexterity</b> saving throw or be knocked prone.</li><li>It must make a <b>Strength</b> saving throw. If it fails, you can push it up to 15 feet away from you.</li><li>It can’t take reactions until the end of your next turn.</li></ul> Saving throw <b>DC ${10 + actor.data.data.abilities.wis.mod}</b>` : \"\";\n\n    const features = [\n        new KiFeature(\"Ki: Flurry of Blows\",\n            `Immediately after you take the <b>Attack</b> action on your turn, you can spend 1 ki point to make two unarmed strikes as a bonus action. ${openHand}`,\n            2,\n            function () {\n                // Automatically roll two Unarmed Strike attacks\n                let strike = actor.items.find(o => o.data.name === 'Unarmed Strike' && o.data.labels.activation === '1 Action')\n                if (strike) {\n                    strike.roll();\n                    strike.roll();\n                }\n            }),\n        new KiFeature(\"Ki: Patient Defense\",\n            \"You can spend 1 ki point to take the <b>Dodge</b> action as a bonus action on your turn.\",\n            2),\n        new KiFeature(\"Ki: Step of the Wind\",\n            \"You can spend 1 ki point to take the <b>Disengage</b> or <b>Dash</b> action as a bonus action on your turn, and your jump distance is doubled for the turn.\",\n            2),\n        new KiFeature(\"Deflect Missiles\",\n            `Starting at 3rd level, you can use your reaction to deflect or catch the missile when you are hit by a ranged weapon attack. When you do so, the damage you take from the attack is reduced by 1d10 + your Dexterity modifier + your monk level. <br />\n\n        If you reduce the damage to 0, you can catch the missile if it is small enough for you to hold in one hand and you have at least one hand free. If you catch a missile in this way, you can spend 1 ki point to make a ranged attack with the weapon or piece of ammunition you just caught, as part of the same reaction. You make this attack with proficiency, regardless of your weapon proficiencies, and the missile counts as a monk weapon for the attack, which has a normal range of 20 feet and a long range of 60 feet.`,\n            3,\n            null,\n            function () {\n                return `Damage reduction: [[/r 1d10+${actor.data.data.abilities.dex.mod}+${monkLevels}]]`;\n            }),\n        new KiFeature(\"Ki: Stunning Strike\",\n            \"Starting at 5th level, you can interfere with the flow of ki in an opponent’s body. When you hit another creature with a melee weapon attack, you can spend 1 ki point to attempt a stunning strike. The target must succeed on a Constitution saving throw or be <b>stunned</b> until the end of your next turn.\",\n            5,\n            null,\n            function () {\n                // Append the saving throw DC to the chat message\n                return `CON saving throw (DC [[8+${actor.data.data.abilities.wis.mod}+@attributes.prof]])`;\n            }),\n        new KiFeature(\"Ki: Diamond Soul\",\n            `Beginning at 14th level, your mastery of ki grants you proficiency in all saving throws.\n\n        Additionally, whenever you make a saving throw and fail, you can spend 1 ki point to reroll it and take the second result.`,\n            14),\n        new KiFeature(\"Ki: Empty Body\",\n            `Beginning at 18th level, you can use your action to spend 4 ki points to become invisible for 1 minute. During that time, you also have resistance to all damage but force damage.\n\n        Additionally, you can spend 8 ki points to cast the astral projection spell, without needing material components. When you do so, you can’t take any other creatures with you.`,\n            18,\n            null,\n            function () {\n                return \"Note: 4 ki points have been spent. Adjust manually if casting astral projection spell.\";\n            },\n            4),\n    ];\n\n    const consumeKi = (feature, allowNegative, allowHigher) => {\n        let hasAvailableResource = false;\n        let selected = features.find(o => o.name == feature);\n        let kiCost = selected.kiCost || 1;\n\n        // Look for Resources under the Core actor data\n        let resourceKey = Object.keys(actor.data.data.resources).filter(k => actor.data.data.resources[k].label === kiName).shift();\n        if (resourceKey && (actor.data.data.resources[resourceKey].value >= kiCost || allowNegative)) {\n            hasAvailableResource = true;\n            actor.data.data.resources[resourceKey].value -= kiCost;\n        }\n\n        // Look for Ki Points Feat that has uses\n        actor.items.filter(i => i.data.name === kiName && i.data.hasUses && (i.data.data.uses.value >= kiCost || allowNegative)).forEach(i => {\n            hasAvailableResource = true;\n            i.data.data.uses.value -= kiCost\n        })\n\n        if (!hasAvailableResource) {\n            ui.notifications.warn(`${actor.name} does not have any ${kiName} left!`);\n            return false;\n        }\n        if (actor.sheet.rendered) {\n            // Update the actor sheet if it is currently open\n            actor.render(true);\n        }\n\n        if (selected) {\n            selected.render(allowHigher);\n        }\n\n        return true;\n    };\n\n    (async () => {\n        let template = `\n        <form>\n            <div class=\"form-group\">\n                <label>Select feature:</label>\n                <select id=\"feature\" name=\"feature\">`\n        features.filter(o => o.requireLevel <= monkLevels).forEach(o => {\n            template += `<option value=\"${o.name}\">${o.name}</option>`;\n        });\n        template += `</select>\n            </div>\n            <div class=\"form-group\">\n                <label>Allow consuming Ki into negative? <input type=\"checkbox\" id=\"allow-negative\" name=\"allow-negative\" value=\"1\"></label>\n            </div>\n            <div class=\"form-group\">\n                <label>Allow consuming Ki feats of higher level? <input type=\"checkbox\" id=\"allow-higher\" name=\"allow-higher\" value=\"1\"></label>\n            </div>\n        </form>`;\n        new Dialog({\n            title: `Monk Ki Point Spender`,\n            content: template,\n            buttons: {\n                yes: {\n                    icon: \"<i class='fas fa-check'></i>\",\n                    label: `Apply`,\n                    callback: (html) => {\n                        let feature = html.find('#feature')[0].value;\n                        let allowNegative = html.find('#allow-negative')[0].checked;\n                        let allowHigher = html.find('#allow-higher')[0].checked;\n                        consumeKi(feature, allowNegative, allowHigher);\n                    }\n                },\n                no: {\n                    icon: \"<i class='fas fa-times'></i>\",\n                    label: `Cancel`\n                },\n            },\n            default: \"yes\"\n        }).render(true);\n    })();\n})()\n","author":"y5gmtwxmW3A5ZuOP","img":"icons/svg/dice-target.svg","actorIds":[],"_id":"zKbQ7lPYQC96DlIS"}
